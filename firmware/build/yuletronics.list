
build/yuletronics.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
 80000c4:	f380 8808 	msr	MSP, r0
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
 80000ca:	f380 8809 	msr	PSP, r0
 80000ce:	2002      	movs	r0, #2
 80000d0:	f380 8814 	msr	CONTROL, r0
 80000d4:	f3bf 8f6f 	isb	sy
 80000d8:	f001 f872 	bl	80011c0 <__core_init>
 80000dc:	f000 faa0 	bl	8000620 <__early_init>
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
 80000e6:	4291      	cmp	r1, r2
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
 80000ea:	6008      	str	r0, [r1, #0]
 80000ec:	3104      	adds	r1, #4
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
 80000f4:	4291      	cmp	r1, r2
 80000f6:	da02      	bge.n	80000fe <endpsloop>
 80000f8:	6008      	str	r0, [r1, #0]
 80000fa:	3104      	adds	r1, #4
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
 8000104:	429a      	cmp	r2, r3
 8000106:	da04      	bge.n	8000112 <enddloop>
 8000108:	6808      	ldr	r0, [r1, #0]
 800010a:	6010      	str	r0, [r2, #0]
 800010c:	3104      	adds	r1, #4
 800010e:	3204      	adds	r2, #4
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
 8000112:	2000      	movs	r0, #0
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
 8000118:	4291      	cmp	r1, r2
 800011a:	da02      	bge.n	8000122 <endbloop>
 800011c:	6008      	str	r0, [r1, #0]
 800011e:	3104      	adds	r1, #4
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
 8000122:	f001 f80d 	bl	8001140 <__init_ram_areas>
 8000126:	f001 f843 	bl	80011b0 <__late_init>
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
 800012e:	42ac      	cmp	r4, r5
 8000130:	da03      	bge.n	800013a <endinitloop>
 8000132:	6821      	ldr	r1, [r4, #0]
 8000134:	4788      	blx	r1
 8000136:	3404      	adds	r4, #4
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
 800013a:	f000 fdb9 	bl	8000cb0 <main>
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
 8000142:	42ac      	cmp	r4, r5
 8000144:	da03      	bge.n	800014e <endfiniloop>
 8000146:	6821      	ldr	r1, [r4, #0]
 8000148:	4788      	blx	r1
 800014a:	3404      	adds	r4, #4
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000400 	.word	0x20000400
 800015c:	55555555 	.word	0x55555555
 8000160:	20000000 	.word	0x20000000
 8000164:	20000200 	.word	0x20000200
 8000168:	080013e0 	.word	0x080013e0
 800016c:	20000400 	.word	0x20000400
 8000170:	20000400 	.word	0x20000400
 8000174:	20000400 	.word	0x20000400
 8000178:	20000700 	.word	0x20000700
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	080000c0 	.word	0x080000c0
 8000188:	080000c0 	.word	0x080000c0
 800018c:	080011a1 	.word	0x080011a1

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	f000 fad6 	bl	8000760 <_dbg_check_unlock>
 80001b4:	b662      	cpsie	i
 80001b6:	1c28      	adds	r0, r5, #0
 80001b8:	47a0      	blx	r4
 80001ba:	2000      	movs	r0, #0
 80001bc:	f000 ff90 	bl	80010e0 <chThdExit>

080001c0 <_port_switch_from_isr>:
 80001c0:	f000 fafe 	bl	80007c0 <_dbg_check_lock>
 80001c4:	f000 fa84 	bl	80006d0 <chSchDoReschedule>
 80001c8:	f000 faca 	bl	8000760 <_dbg_check_unlock>

080001cc <_port_exit_from_isr>:
 80001cc:	4a01      	ldr	r2, [pc, #4]	; (80001d4 <_port_exit_from_isr+0x8>)
 80001ce:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <_port_exit_from_isr+0xc>)
 80001d0:	6013      	str	r3, [r2, #0]
 80001d2:	e7fe      	b.n	80001d2 <_port_exit_from_isr+0x6>
 80001d4:	e000ed04 	.word	0xe000ed04
 80001d8:	80000000 	.word	0x80000000
 80001dc:	00000000 	.word	0x00000000

080001e0 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80001e0:	4b02      	ldr	r3, [pc, #8]	; (80001ec <Thread1+0xc>)
 80001e2:	4a03      	ldr	r2, [pc, #12]	; (80001f0 <Thread1+0x10>)
 80001e4:	699b      	ldr	r3, [r3, #24]
 80001e6:	619a      	str	r2, [r3, #24]
 80001e8:	e7fe      	b.n	80001e8 <Thread1+0x8>
 80001ea:	46c0      	nop			; (mov r8, r8)
 80001ec:	20000420 	.word	0x20000420
 80001f0:	08001378 	.word	0x08001378
	...

08000200 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8000200:	6982      	ldr	r2, [r0, #24]
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000202:	b570      	push	{r4, r5, r6, lr}
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8000204:	6913      	ldr	r3, [r2, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8000206:	68d4      	ldr	r4, [r2, #12]
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000208:	0005      	movs	r5, r0
 800020a:	401c      	ands	r4, r3
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
 800020c:	23ff      	movs	r3, #255	; 0xff
 800020e:	4023      	ands	r3, r4
 8000210:	43db      	mvns	r3, r3
 8000212:	6113      	str	r3, [r2, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000214:	07a3      	lsls	r3, r4, #30
 8000216:	d504      	bpl.n	8000222 <pwm_lld_serve_interrupt+0x22>
      (pwmp->config->channels[0].callback != NULL))
 8000218:	6843      	ldr	r3, [r0, #4]
 800021a:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800021c:	2b00      	cmp	r3, #0
 800021e:	d000      	beq.n	8000222 <pwm_lld_serve_interrupt+0x22>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 8000220:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000222:	0763      	lsls	r3, r4, #29
 8000224:	d505      	bpl.n	8000232 <pwm_lld_serve_interrupt+0x32>
      (pwmp->config->channels[1].callback != NULL))
 8000226:	686b      	ldr	r3, [r5, #4]
 8000228:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800022a:	2b00      	cmp	r3, #0
 800022c:	d001      	beq.n	8000232 <pwm_lld_serve_interrupt+0x32>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 800022e:	0028      	movs	r0, r5
 8000230:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000232:	0723      	lsls	r3, r4, #28
 8000234:	d505      	bpl.n	8000242 <pwm_lld_serve_interrupt+0x42>
      (pwmp->config->channels[2].callback != NULL))
 8000236:	686b      	ldr	r3, [r5, #4]
 8000238:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800023a:	2b00      	cmp	r3, #0
 800023c:	d001      	beq.n	8000242 <pwm_lld_serve_interrupt+0x42>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 800023e:	0028      	movs	r0, r5
 8000240:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000242:	06e3      	lsls	r3, r4, #27
 8000244:	d505      	bpl.n	8000252 <pwm_lld_serve_interrupt+0x52>
      (pwmp->config->channels[3].callback != NULL))
 8000246:	686b      	ldr	r3, [r5, #4]
 8000248:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800024a:	2b00      	cmp	r3, #0
 800024c:	d001      	beq.n	8000252 <pwm_lld_serve_interrupt+0x52>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 800024e:	0028      	movs	r0, r5
 8000250:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8000252:	07e3      	lsls	r3, r4, #31
 8000254:	d505      	bpl.n	8000262 <pwm_lld_serve_interrupt+0x62>
 8000256:	686b      	ldr	r3, [r5, #4]
 8000258:	689b      	ldr	r3, [r3, #8]
 800025a:	2b00      	cmp	r3, #0
 800025c:	d001      	beq.n	8000262 <pwm_lld_serve_interrupt+0x62>
    pwmp->config->callback(pwmp);
 800025e:	0028      	movs	r0, r5
 8000260:	4798      	blx	r3
}
 8000262:	bd70      	pop	{r4, r5, r6, pc}
	...

08000270 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000270:	300f      	adds	r0, #15
 8000272:	d011      	beq.n	8000298 <_port_irq_epilogue+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000274:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000276:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800027a:	3b20      	subs	r3, #32
 800027c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000280:	2280      	movs	r2, #128	; 0x80
 8000282:	0452      	lsls	r2, r2, #17
 8000284:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000286:	4a06      	ldr	r2, [pc, #24]	; (80002a0 <_port_irq_epilogue+0x30>)
 8000288:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800028a:	6992      	ldr	r2, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800028c:	6889      	ldr	r1, [r1, #8]
 800028e:	6892      	ldr	r2, [r2, #8]
 8000290:	4291      	cmp	r1, r2
 8000292:	d802      	bhi.n	800029a <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000294:	4a03      	ldr	r2, [pc, #12]	; (80002a4 <_port_irq_epilogue+0x34>)
 8000296:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000298:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800029a:	4a03      	ldr	r2, [pc, #12]	; (80002a8 <_port_irq_epilogue+0x38>)
 800029c:	619a      	str	r2, [r3, #24]
 800029e:	e7fb      	b.n	8000298 <_port_irq_epilogue+0x28>
 80002a0:	20000420 	.word	0x20000420
 80002a4:	080001cc 	.word	0x080001cc
 80002a8:	080001c1 	.word	0x080001c1
 80002ac:	00000000 	.word	0x00000000

080002b0 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80002b0:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80002b4:	3320      	adds	r3, #32
 80002b6:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80002ba:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80002bc:	4770      	bx	lr
 80002be:	46c0      	nop			; (mov r8, r8)

080002c0 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80002c0:	4b05      	ldr	r3, [pc, #20]	; (80002d8 <chDbgCheckClassS+0x18>)
 80002c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80002c4:	2a00      	cmp	r2, #0
 80002c6:	d103      	bne.n	80002d0 <chDbgCheckClassS+0x10>
 80002c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80002ca:	2a00      	cmp	r2, #0
 80002cc:	dd00      	ble.n	80002d0 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 80002ce:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80002d0:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80002d2:	4a02      	ldr	r2, [pc, #8]	; (80002dc <chDbgCheckClassS+0x1c>)
 80002d4:	62da      	str	r2, [r3, #44]	; 0x2c
 80002d6:	e7fe      	b.n	80002d6 <chDbgCheckClassS+0x16>
 80002d8:	20000420 	.word	0x20000420
 80002dc:	08001380 	.word	0x08001380

080002e0 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80002e0:	4b05      	ldr	r3, [pc, #20]	; (80002f8 <chDbgCheckClassI+0x18>)
 80002e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80002e4:	2a00      	cmp	r2, #0
 80002e6:	db03      	blt.n	80002f0 <chDbgCheckClassI+0x10>
 80002e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80002ea:	2a00      	cmp	r2, #0
 80002ec:	dd00      	ble.n	80002f0 <chDbgCheckClassI+0x10>
    chSysHalt("SV#10");
  }
}
 80002ee:	4770      	bx	lr
 80002f0:	b672      	cpsid	i
 80002f2:	4a02      	ldr	r2, [pc, #8]	; (80002fc <chDbgCheckClassI+0x1c>)
 80002f4:	62da      	str	r2, [r3, #44]	; 0x2c
 80002f6:	e7fe      	b.n	80002f6 <chDbgCheckClassI+0x16>
 80002f8:	20000420 	.word	0x20000420
 80002fc:	08001388 	.word	0x08001388

08000300 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000300:	b510      	push	{r4, lr}
 8000302:	0004      	movs	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 8000304:	f7ff ffec 	bl	80002e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000308:	2c00      	cmp	r4, #0
 800030a:	d019      	beq.n	8000340 <chSchReadyI+0x40>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800030c:	2320      	movs	r3, #32
 800030e:	5ce2      	ldrb	r2, [r4, r3]
 8000310:	2a00      	cmp	r2, #0
 8000312:	d010      	beq.n	8000336 <chSchReadyI+0x36>
 8000314:	2a0f      	cmp	r2, #15
 8000316:	d00e      	beq.n	8000336 <chSchReadyI+0x36>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000318:	2200      	movs	r2, #0
 800031a:	54e2      	strb	r2, [r4, r3]
 800031c:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 800031e:	4b0b      	ldr	r3, [pc, #44]	; (800034c <chSchReadyI+0x4c>)
  do {
    cp = cp->queue.next;
 8000320:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000322:	6899      	ldr	r1, [r3, #8]
 8000324:	4291      	cmp	r1, r2
 8000326:	d2fb      	bcs.n	8000320 <chSchReadyI+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000328:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800032a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 800032c:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800032e:	0020      	movs	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8000330:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000332:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000334:	bd10      	pop	{r4, pc}
 8000336:	b672      	cpsid	i
 8000338:	4a05      	ldr	r2, [pc, #20]	; (8000350 <chSchReadyI+0x50>)
 800033a:	4b04      	ldr	r3, [pc, #16]	; (800034c <chSchReadyI+0x4c>)
 800033c:	62da      	str	r2, [r3, #44]	; 0x2c
 800033e:	e7fe      	b.n	800033e <chSchReadyI+0x3e>
 8000340:	b672      	cpsid	i
 8000342:	4a03      	ldr	r2, [pc, #12]	; (8000350 <chSchReadyI+0x50>)
 8000344:	4b01      	ldr	r3, [pc, #4]	; (800034c <chSchReadyI+0x4c>)
 8000346:	62da      	str	r2, [r3, #44]	; 0x2c
 8000348:	e7fe      	b.n	8000348 <chSchReadyI+0x48>
 800034a:	46c0      	nop			; (mov r8, r8)
 800034c:	20000420 	.word	0x20000420
 8000350:	08001200 	.word	0x08001200
	...

08000360 <_dbg_check_leave_isr>:
 8000360:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000362:	4b07      	ldr	r3, [pc, #28]	; (8000380 <_dbg_check_leave_isr+0x20>)
 8000364:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000366:	2a00      	cmp	r2, #0
 8000368:	dd02      	ble.n	8000370 <_dbg_check_leave_isr+0x10>
 800036a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800036c:	2900      	cmp	r1, #0
 800036e:	d003      	beq.n	8000378 <_dbg_check_leave_isr+0x18>
 8000370:	b672      	cpsid	i
 8000372:	4a04      	ldr	r2, [pc, #16]	; (8000384 <_dbg_check_leave_isr+0x24>)
 8000374:	62da      	str	r2, [r3, #44]	; 0x2c
 8000376:	e7fe      	b.n	8000376 <_dbg_check_leave_isr+0x16>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8000378:	3a01      	subs	r2, #1
 800037a:	631a      	str	r2, [r3, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800037c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800037e:	4770      	bx	lr
 8000380:	20000420 	.word	0x20000420
 8000384:	08001390 	.word	0x08001390
	...

08000390 <_dbg_check_enter_isr>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000390:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000392:	4b07      	ldr	r3, [pc, #28]	; (80003b0 <_dbg_check_enter_isr+0x20>)
 8000394:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000396:	2a00      	cmp	r2, #0
 8000398:	db02      	blt.n	80003a0 <_dbg_check_enter_isr+0x10>
 800039a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800039c:	2900      	cmp	r1, #0
 800039e:	d003      	beq.n	80003a8 <_dbg_check_enter_isr+0x18>
 80003a0:	b672      	cpsid	i
 80003a2:	4a04      	ldr	r2, [pc, #16]	; (80003b4 <_dbg_check_enter_isr+0x24>)
 80003a4:	62da      	str	r2, [r3, #44]	; 0x2c
 80003a6:	e7fe      	b.n	80003a6 <_dbg_check_enter_isr+0x16>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 80003a8:	3201      	adds	r2, #1
 80003aa:	631a      	str	r2, [r3, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003ac:	b662      	cpsie	i
  port_unlock_from_isr();
}
 80003ae:	4770      	bx	lr
 80003b0:	20000420 	.word	0x20000420
 80003b4:	08001398 	.word	0x08001398
	...

080003c0 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80003c0:	4b06      	ldr	r3, [pc, #24]	; (80003dc <_dbg_check_unlock_from_isr+0x1c>)
 80003c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003c4:	2a00      	cmp	r2, #0
 80003c6:	dd05      	ble.n	80003d4 <_dbg_check_unlock_from_isr+0x14>
 80003c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80003ca:	2a00      	cmp	r2, #0
 80003cc:	dd02      	ble.n	80003d4 <_dbg_check_unlock_from_isr+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 80003ce:	2200      	movs	r2, #0
 80003d0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80003d2:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003d4:	b672      	cpsid	i
 80003d6:	4a02      	ldr	r2, [pc, #8]	; (80003e0 <_dbg_check_unlock_from_isr+0x20>)
 80003d8:	62da      	str	r2, [r3, #44]	; 0x2c
 80003da:	e7fe      	b.n	80003da <_dbg_check_unlock_from_isr+0x1a>
 80003dc:	20000420 	.word	0x20000420
 80003e0:	080013a0 	.word	0x080013a0
	...

080003f0 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80003f0:	4b06      	ldr	r3, [pc, #24]	; (800040c <_dbg_check_lock_from_isr+0x1c>)
 80003f2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003f4:	2a00      	cmp	r2, #0
 80003f6:	dd02      	ble.n	80003fe <_dbg_check_lock_from_isr+0xe>
 80003f8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80003fa:	2a00      	cmp	r2, #0
 80003fc:	d003      	beq.n	8000406 <_dbg_check_lock_from_isr+0x16>
 80003fe:	b672      	cpsid	i
 8000400:	4a03      	ldr	r2, [pc, #12]	; (8000410 <_dbg_check_lock_from_isr+0x20>)
 8000402:	62da      	str	r2, [r3, #44]	; 0x2c
 8000404:	e7fe      	b.n	8000404 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8000406:	2201      	movs	r2, #1
 8000408:	635a      	str	r2, [r3, #52]	; 0x34
}
 800040a:	4770      	bx	lr
 800040c:	20000420 	.word	0x20000420
 8000410:	080013a8 	.word	0x080013a8
	...

08000420 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000420:	b570      	push	{r4, r5, r6, lr}
 8000422:	0004      	movs	r4, r0
 8000424:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000426:	f7ff ffe3 	bl	80003f0 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800042a:	2320      	movs	r3, #32
 800042c:	5ce3      	ldrb	r3, [r4, r3]
 800042e:	2b07      	cmp	r3, #7
 8000430:	d80e      	bhi.n	8000450 <wakeup+0x30>
 8000432:	4a11      	ldr	r2, [pc, #68]	; (8000478 <wakeup+0x58>)
 8000434:	009b      	lsls	r3, r3, #2
 8000436:	58d3      	ldr	r3, [r2, r3]
 8000438:	469f      	mov	pc, r3
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800043a:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 800043c:	f7ff ff50 	bl	80002e0 <chDbgCheckClassI>

  sp->cnt++;
 8000440:	68ab      	ldr	r3, [r5, #8]
 8000442:	3301      	adds	r3, #1
 8000444:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000446:	6822      	ldr	r2, [r4, #0]
 8000448:	6863      	ldr	r3, [r4, #4]
 800044a:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800044c:	6822      	ldr	r2, [r4, #0]
 800044e:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000450:	2301      	movs	r3, #1
 8000452:	425b      	negs	r3, r3
 8000454:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000456:	0020      	movs	r0, r4
 8000458:	f7ff ff52 	bl	8000300 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800045c:	f7ff ffb0 	bl	80003c0 <_dbg_check_unlock_from_isr>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000460:	b662      	cpsie	i
  chSysUnlockFromISR();
}
 8000462:	bd70      	pop	{r4, r5, r6, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8000464:	2200      	movs	r2, #0
 8000466:	6a63      	ldr	r3, [r4, #36]	; 0x24
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
 8000468:	0020      	movs	r0, r4
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800046a:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800046c:	2301      	movs	r3, #1
 800046e:	425b      	negs	r3, r3
 8000470:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000472:	f7ff ff45 	bl	8000300 <chSchReadyI>
 8000476:	e7f1      	b.n	800045c <wakeup+0x3c>
 8000478:	080011c4 	.word	0x080011c4
 800047c:	00000000 	.word	0x00000000

08000480 <_idle_thread>:
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8000480:	bf30      	wfi
 8000482:	e7fd      	b.n	8000480 <_idle_thread>
	...

08000490 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000490:	e7fe      	b.n	8000490 <BusFault_Handler>
 8000492:	46c0      	nop			; (mov r8, r8)
	...

080004a0 <chSchWakeupS.constprop.11>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80004a0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 80004a2:	4d17      	ldr	r5, [pc, #92]	; (8000500 <chSchWakeupS.constprop.11+0x60>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80004a4:	0004      	movs	r4, r0
  thread_t *otp = currp;
 80004a6:	69ae      	ldr	r6, [r5, #24]

  chDbgCheckClassS();
 80004a8:	f7ff ff0a 	bl	80002c0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80004ac:	682a      	ldr	r2, [r5, #0]
 80004ae:	68b3      	ldr	r3, [r6, #8]
 80004b0:	42aa      	cmp	r2, r5
 80004b2:	d002      	beq.n	80004ba <chSchWakeupS.constprop.11+0x1a>
 80004b4:	6892      	ldr	r2, [r2, #8]
 80004b6:	4293      	cmp	r3, r2
 80004b8:	d31e      	bcc.n	80004f8 <chSchWakeupS.constprop.11+0x58>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80004ba:	2200      	movs	r2, #0
 80004bc:	6262      	str	r2, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80004be:	68a2      	ldr	r2, [r4, #8]
 80004c0:	429a      	cmp	r2, r3
 80004c2:	d915      	bls.n	80004f0 <chSchWakeupS.constprop.11+0x50>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 80004c4:	0030      	movs	r0, r6
 80004c6:	f7ff ff1b 	bl	8000300 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80004ca:	2201      	movs	r2, #1
 80004cc:	2320      	movs	r3, #32
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 80004ce:	0001      	movs	r1, r0
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80004d0:	61ac      	str	r4, [r5, #24]
    ntp->state = CH_STATE_CURRENT;
 80004d2:	54e2      	strb	r2, [r4, r3]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80004d4:	f3ef 8309 	mrs	r3, PSP

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80004d8:	69c2      	ldr	r2, [r0, #28]
 80004da:	3b24      	subs	r3, #36	; 0x24
 80004dc:	429a      	cmp	r2, r3
 80004de:	d803      	bhi.n	80004e8 <chSchWakeupS.constprop.11+0x48>
 80004e0:	0020      	movs	r0, r4
 80004e2:	f7ff fe55 	bl	8000190 <_port_switch>
  }
}
 80004e6:	bd70      	pop	{r4, r5, r6, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004e8:	b672      	cpsid	i
 80004ea:	4b06      	ldr	r3, [pc, #24]	; (8000504 <chSchWakeupS.constprop.11+0x64>)
 80004ec:	62eb      	str	r3, [r5, #44]	; 0x2c
 80004ee:	e7fe      	b.n	80004ee <chSchWakeupS.constprop.11+0x4e>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 80004f0:	0020      	movs	r0, r4
 80004f2:	f7ff ff05 	bl	8000300 <chSchReadyI>
 80004f6:	e7f6      	b.n	80004e6 <chSchWakeupS.constprop.11+0x46>
 80004f8:	b672      	cpsid	i
 80004fa:	4b03      	ldr	r3, [pc, #12]	; (8000508 <chSchWakeupS.constprop.11+0x68>)
 80004fc:	62eb      	str	r3, [r5, #44]	; 0x2c
 80004fe:	e7fe      	b.n	80004fe <chSchWakeupS.constprop.11+0x5e>
 8000500:	20000420 	.word	0x20000420
 8000504:	080013b0 	.word	0x080013b0
 8000508:	08001314 	.word	0x08001314
 800050c:	00000000 	.word	0x00000000

08000510 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000510:	b570      	push	{r4, r5, r6, lr}
 8000512:	0006      	movs	r6, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 8000514:	f7ff fed4 	bl	80002c0 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 8000518:	2320      	movs	r3, #32
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 800051a:	4c0c      	ldr	r4, [pc, #48]	; (800054c <chSchGoSleepS+0x3c>)
 800051c:	69a5      	ldr	r5, [r4, #24]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800051e:	6820      	ldr	r0, [r4, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000520:	54ee      	strb	r6, [r5, r3]

  tqp->next             = tp->queue.next;
 8000522:	6802      	ldr	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000524:	6054      	str	r4, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000526:	6022      	str	r2, [r4, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000528:	2201      	movs	r2, #1
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800052a:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 800052c:	54c2      	strb	r2, [r0, r3]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800052e:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000532:	69ea      	ldr	r2, [r5, #28]
 8000534:	3b24      	subs	r3, #36	; 0x24
 8000536:	429a      	cmp	r2, r3
 8000538:	d803      	bhi.n	8000542 <chSchGoSleepS+0x32>
 800053a:	0029      	movs	r1, r5
 800053c:	f7ff fe28 	bl	8000190 <_port_switch>
}
 8000540:	bd70      	pop	{r4, r5, r6, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000542:	b672      	cpsid	i
 8000544:	4b02      	ldr	r3, [pc, #8]	; (8000550 <chSchGoSleepS+0x40>)
 8000546:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000548:	e7fe      	b.n	8000548 <chSchGoSleepS+0x38>
 800054a:	46c0      	nop			; (mov r8, r8)
 800054c:	20000420 	.word	0x20000420
 8000550:	080013b0 	.word	0x080013b0
	...

08000560 <Vector80>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8000560:	b510      	push	{r4, lr}
 8000562:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000564:	f7ff ff14 	bl	8000390 <_dbg_check_enter_isr>

  pwm_lld_serve_interrupt(&PWMD3);
 8000568:	4804      	ldr	r0, [pc, #16]	; (800057c <Vector80+0x1c>)
 800056a:	f7ff fe49 	bl	8000200 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800056e:	f7ff fef7 	bl	8000360 <_dbg_check_leave_isr>
 8000572:	0020      	movs	r0, r4
 8000574:	f7ff fe7c 	bl	8000270 <_port_irq_epilogue>
}
 8000578:	bd10      	pop	{r4, pc}
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	200004b8 	.word	0x200004b8

08000580 <Vector7C>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000580:	b510      	push	{r4, lr}
 8000582:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000584:	f7ff ff04 	bl	8000390 <_dbg_check_enter_isr>

  pwm_lld_serve_interrupt(&PWMD2);
 8000588:	4804      	ldr	r0, [pc, #16]	; (800059c <Vector7C+0x1c>)
 800058a:	f7ff fe39 	bl	8000200 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800058e:	f7ff fee7 	bl	8000360 <_dbg_check_leave_isr>
 8000592:	0020      	movs	r0, r4
 8000594:	f7ff fe6c 	bl	8000270 <_port_irq_epilogue>
}
 8000598:	bd10      	pop	{r4, pc}
 800059a:	46c0      	nop			; (mov r8, r8)
 800059c:	2000049c 	.word	0x2000049c

080005a0 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 80005a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80005a2:	464f      	mov	r7, r9
 80005a4:	4646      	mov	r6, r8
 80005a6:	b4c0      	push	{r6, r7}

  OSAL_IRQ_PROLOGUE();
 80005a8:	46f1      	mov	r9, lr
 80005aa:	f7ff fef1 	bl	8000390 <_dbg_check_enter_isr>
 80005ae:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80005b0:	f7ff ff1e 	bl	80003f0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 80005b4:	f7ff fe94 	bl	80002e0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 80005b8:	f7ff fe92 	bl	80002e0 <chDbgCheckClassI>

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 80005bc:	4d16      	ldr	r5, [pc, #88]	; (8000618 <SysTick_Handler+0x78>)
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 80005be:	002f      	movs	r7, r5
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 80005c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 80005c2:	69ec      	ldr	r4, [r5, #28]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 80005c4:	3301      	adds	r3, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 80005c6:	371c      	adds	r7, #28
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 80005c8:	62ab      	str	r3, [r5, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 80005ca:	42bc      	cmp	r4, r7
 80005cc:	d017      	beq.n	80005fe <SysTick_Handler+0x5e>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
 80005ce:	68a3      	ldr	r3, [r4, #8]
 80005d0:	3b01      	subs	r3, #1
 80005d2:	60a3      	str	r3, [r4, #8]
    while (ch.vtlist.next->delta == (systime_t)0) {
 80005d4:	2b00      	cmp	r3, #0
 80005d6:	d112      	bne.n	80005fe <SysTick_Handler+0x5e>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
      vtp->func = NULL;
 80005d8:	4698      	mov	r8, r3
 80005da:	4643      	mov	r3, r8
    while (ch.vtlist.next->delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
 80005dc:	68e6      	ldr	r6, [r4, #12]
      vtp->func = NULL;
 80005de:	60e3      	str	r3, [r4, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80005e0:	6823      	ldr	r3, [r4, #0]
 80005e2:	605f      	str	r7, [r3, #4]
      ch.vtlist.next = vtp->next;
 80005e4:	61eb      	str	r3, [r5, #28]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80005e6:	f7ff feeb 	bl	80003c0 <_dbg_check_unlock_from_isr>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005ea:	b662      	cpsie	i
      chSysUnlockFromISR();
      fn(vtp->par);
 80005ec:	6920      	ldr	r0, [r4, #16]
 80005ee:	47b0      	blx	r6
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005f0:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80005f2:	f7ff fefd 	bl	80003f0 <_dbg_check_lock_from_isr>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
    while (ch.vtlist.next->delta == (systime_t)0) {
 80005f6:	69ec      	ldr	r4, [r5, #28]
 80005f8:	68a3      	ldr	r3, [r4, #8]
 80005fa:	2b00      	cmp	r3, #0
 80005fc:	d0ed      	beq.n	80005da <SysTick_Handler+0x3a>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80005fe:	f7ff fedf 	bl	80003c0 <_dbg_check_unlock_from_isr>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000602:	b662      	cpsie	i

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 8000604:	f7ff feac 	bl	8000360 <_dbg_check_leave_isr>
 8000608:	4648      	mov	r0, r9
 800060a:	f7ff fe31 	bl	8000270 <_port_irq_epilogue>
}
 800060e:	bc0c      	pop	{r2, r3}
 8000610:	4690      	mov	r8, r2
 8000612:	4699      	mov	r9, r3
 8000614:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000616:	46c0      	nop			; (mov r8, r8)
 8000618:	20000420 	.word	0x20000420
 800061c:	00000000 	.word	0x00000000

08000620 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000620:	2301      	movs	r3, #1
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000622:	2002      	movs	r0, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000624:	4927      	ldr	r1, [pc, #156]	; (80006c4 <__early_init+0xa4>)
 8000626:	680a      	ldr	r2, [r1, #0]
 8000628:	4313      	orrs	r3, r2
 800062a:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800062c:	680a      	ldr	r2, [r1, #0]
 800062e:	4b25      	ldr	r3, [pc, #148]	; (80006c4 <__early_init+0xa4>)
 8000630:	4210      	tst	r0, r2
 8000632:	d0fb      	beq.n	800062c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000634:	2103      	movs	r1, #3
 8000636:	685a      	ldr	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000638:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800063a:	438a      	bics	r2, r1
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800063c:	0019      	movs	r1, r3
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800063e:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000640:	685a      	ldr	r2, [r3, #4]
 8000642:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000644:	684b      	ldr	r3, [r1, #4]
 8000646:	4a1f      	ldr	r2, [pc, #124]	; (80006c4 <__early_init+0xa4>)
 8000648:	4003      	ands	r3, r0
 800064a:	d1fb      	bne.n	8000644 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800064c:	20f9      	movs	r0, #249	; 0xf9
 800064e:	6811      	ldr	r1, [r2, #0]
 8000650:	4001      	ands	r1, r0
 8000652:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000654:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000656:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000658:	3301      	adds	r3, #1
 800065a:	430b      	orrs	r3, r1
 800065c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800065e:	38f7      	subs	r0, #247	; 0xf7
 8000660:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000662:	4b18      	ldr	r3, [pc, #96]	; (80006c4 <__early_init+0xa4>)
 8000664:	4208      	tst	r0, r1
 8000666:	d0fb      	beq.n	8000660 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000668:	2201      	movs	r2, #1
 800066a:	6a59      	ldr	r1, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800066c:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800066e:	430a      	orrs	r2, r1
 8000670:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000672:	001a      	movs	r2, r3
 8000674:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8000676:	4b13      	ldr	r3, [pc, #76]	; (80006c4 <__early_init+0xa4>)
 8000678:	4208      	tst	r0, r1
 800067a:	d0fb      	beq.n	8000674 <__early_init+0x54>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800067c:	22a0      	movs	r2, #160	; 0xa0
 800067e:	0392      	lsls	r2, r2, #14
 8000680:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8000682:	2200      	movs	r2, #0
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000684:	2180      	movs	r1, #128	; 0x80
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000686:	2080      	movs	r0, #128	; 0x80
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8000688:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 800068a:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 800068c:	681a      	ldr	r2, [r3, #0]
 800068e:	0449      	lsls	r1, r1, #17
 8000690:	430a      	orrs	r2, r1
 8000692:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000694:	0480      	lsls	r0, r0, #18
 8000696:	6819      	ldr	r1, [r3, #0]
 8000698:	4a0a      	ldr	r2, [pc, #40]	; (80006c4 <__early_init+0xa4>)
 800069a:	4201      	tst	r1, r0
 800069c:	d0fb      	beq.n	8000696 <__early_init+0x76>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800069e:	2111      	movs	r1, #17
 80006a0:	4b09      	ldr	r3, [pc, #36]	; (80006c8 <__early_init+0xa8>)

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80006a2:	200c      	movs	r0, #12
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80006a4:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80006a6:	2302      	movs	r3, #2
 80006a8:	6851      	ldr	r1, [r2, #4]
 80006aa:	430b      	orrs	r3, r1
 80006ac:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80006ae:	6853      	ldr	r3, [r2, #4]
 80006b0:	4904      	ldr	r1, [pc, #16]	; (80006c4 <__early_init+0xa4>)
 80006b2:	4003      	ands	r3, r0
 80006b4:	2b08      	cmp	r3, #8
 80006b6:	d1fa      	bne.n	80006ae <__early_init+0x8e>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80006b8:	698a      	ldr	r2, [r1, #24]
 80006ba:	3b07      	subs	r3, #7
 80006bc:	4313      	orrs	r3, r2
 80006be:	618b      	str	r3, [r1, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 80006c0:	4770      	bx	lr
 80006c2:	46c0      	nop			; (mov r8, r8)
 80006c4:	40021000 	.word	0x40021000
 80006c8:	40022000 	.word	0x40022000
 80006cc:	00000000 	.word	0x00000000

080006d0 <chSchDoReschedule>:
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80006d0:	2320      	movs	r3, #32
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80006d2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006d4:	4647      	mov	r7, r8
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80006d6:	4698      	mov	r8, r3
 80006d8:	4642      	mov	r2, r8
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 80006da:	4d1d      	ldr	r5, [pc, #116]	; (8000750 <chSchDoReschedule+0x80>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80006dc:	b480      	push	{r7}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80006de:	682f      	ldr	r7, [r5, #0]
  thread_t *otp = currp;
 80006e0:	69ac      	ldr	r4, [r5, #24]

  tqp->next             = tp->queue.next;
 80006e2:	683e      	ldr	r6, [r7, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80006e4:	3b1f      	subs	r3, #31
  tqp->next->queue.prev = (thread_t *)tqp;
 80006e6:	6075      	str	r5, [r6, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80006e8:	602e      	str	r6, [r5, #0]
 80006ea:	54bb      	strb	r3, [r7, r2]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80006ec:	61af      	str	r7, [r5, #24]
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
 80006ee:	f7ff fdf7 	bl	80002e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80006f2:	2c00      	cmp	r4, #0
 80006f4:	d024      	beq.n	8000740 <chSchDoReschedule+0x70>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80006f6:	4643      	mov	r3, r8
 80006f8:	5ce3      	ldrb	r3, [r4, r3]
 80006fa:	2b00      	cmp	r3, #0
 80006fc:	d01c      	beq.n	8000738 <chSchDoReschedule+0x68>
 80006fe:	2b0f      	cmp	r3, #15
 8000700:	d01a      	beq.n	8000738 <chSchDoReschedule+0x68>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000702:	2300      	movs	r3, #0
 8000704:	4642      	mov	r2, r8
 8000706:	54a3      	strb	r3, [r4, r2]
 8000708:	68a3      	ldr	r3, [r4, #8]
 800070a:	e000      	b.n	800070e <chSchDoReschedule+0x3e>
 800070c:	6836      	ldr	r6, [r6, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800070e:	68b2      	ldr	r2, [r6, #8]
 8000710:	429a      	cmp	r2, r3
 8000712:	d8fb      	bhi.n	800070c <chSchDoReschedule+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000714:	6873      	ldr	r3, [r6, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000716:	6026      	str	r6, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8000718:	6063      	str	r3, [r4, #4]
  tp->queue.prev->queue.next = tp;
 800071a:	601c      	str	r4, [r3, #0]
  cp->queue.prev             = tp;
 800071c:	6074      	str	r4, [r6, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800071e:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000722:	69e2      	ldr	r2, [r4, #28]
 8000724:	3b24      	subs	r3, #36	; 0x24
 8000726:	429a      	cmp	r2, r3
 8000728:	d80e      	bhi.n	8000748 <chSchDoReschedule+0x78>
 800072a:	0038      	movs	r0, r7
 800072c:	0021      	movs	r1, r4
 800072e:	f7ff fd2f 	bl	8000190 <_port_switch>
}
 8000732:	bc04      	pop	{r2}
 8000734:	4690      	mov	r8, r2
 8000736:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000738:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800073a:	4b06      	ldr	r3, [pc, #24]	; (8000754 <chSchDoReschedule+0x84>)
 800073c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800073e:	e7fe      	b.n	800073e <chSchDoReschedule+0x6e>
 8000740:	b672      	cpsid	i
 8000742:	4b04      	ldr	r3, [pc, #16]	; (8000754 <chSchDoReschedule+0x84>)
 8000744:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000746:	e7fe      	b.n	8000746 <chSchDoReschedule+0x76>
 8000748:	b672      	cpsid	i
 800074a:	4b03      	ldr	r3, [pc, #12]	; (8000758 <chSchDoReschedule+0x88>)
 800074c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800074e:	e7fe      	b.n	800074e <chSchDoReschedule+0x7e>
 8000750:	20000420 	.word	0x20000420
 8000754:	0800122c 	.word	0x0800122c
 8000758:	080013b0 	.word	0x080013b0
 800075c:	00000000 	.word	0x00000000

08000760 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000760:	4b06      	ldr	r3, [pc, #24]	; (800077c <_dbg_check_unlock+0x1c>)
 8000762:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000764:	2a00      	cmp	r2, #0
 8000766:	d104      	bne.n	8000772 <_dbg_check_unlock+0x12>
 8000768:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800076a:	2900      	cmp	r1, #0
 800076c:	dd01      	ble.n	8000772 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800076e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000770:	4770      	bx	lr
 8000772:	b672      	cpsid	i
 8000774:	4a02      	ldr	r2, [pc, #8]	; (8000780 <_dbg_check_unlock+0x20>)
 8000776:	62da      	str	r2, [r3, #44]	; 0x2c
 8000778:	e7fe      	b.n	8000778 <_dbg_check_unlock+0x18>
 800077a:	46c0      	nop			; (mov r8, r8)
 800077c:	20000420 	.word	0x20000420
 8000780:	080013c0 	.word	0x080013c0
	...

08000790 <chSysUnlock.lto_priv.14>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000790:	b510      	push	{r4, lr}

  _dbg_check_unlock();
 8000792:	f7ff ffe5 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000796:	4b07      	ldr	r3, [pc, #28]	; (80007b4 <chSysUnlock.lto_priv.14+0x24>)
 8000798:	681a      	ldr	r2, [r3, #0]
 800079a:	429a      	cmp	r2, r3
 800079c:	d004      	beq.n	80007a8 <chSysUnlock.lto_priv.14+0x18>
 800079e:	6999      	ldr	r1, [r3, #24]
 80007a0:	6892      	ldr	r2, [r2, #8]
 80007a2:	6889      	ldr	r1, [r1, #8]
 80007a4:	4291      	cmp	r1, r2
 80007a6:	d301      	bcc.n	80007ac <chSysUnlock.lto_priv.14+0x1c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80007a8:	b662      	cpsie	i
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
}
 80007aa:	bd10      	pop	{r4, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007ac:	b672      	cpsid	i
 80007ae:	4a02      	ldr	r2, [pc, #8]	; (80007b8 <chSysUnlock.lto_priv.14+0x28>)
 80007b0:	62da      	str	r2, [r3, #44]	; 0x2c
 80007b2:	e7fe      	b.n	80007b2 <chSysUnlock.lto_priv.14+0x22>
 80007b4:	20000420 	.word	0x20000420
 80007b8:	08001358 	.word	0x08001358
 80007bc:	00000000 	.word	0x00000000

080007c0 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80007c0:	4b06      	ldr	r3, [pc, #24]	; (80007dc <_dbg_check_lock+0x1c>)
 80007c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007c4:	2a00      	cmp	r2, #0
 80007c6:	d102      	bne.n	80007ce <_dbg_check_lock+0xe>
 80007c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80007ca:	2a00      	cmp	r2, #0
 80007cc:	d003      	beq.n	80007d6 <_dbg_check_lock+0x16>
 80007ce:	b672      	cpsid	i
 80007d0:	4a03      	ldr	r2, [pc, #12]	; (80007e0 <_dbg_check_lock+0x20>)
 80007d2:	62da      	str	r2, [r3, #44]	; 0x2c
 80007d4:	e7fe      	b.n	80007d4 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80007d6:	2201      	movs	r2, #1
 80007d8:	635a      	str	r2, [r3, #52]	; 0x34
}
 80007da:	4770      	bx	lr
 80007dc:	20000420 	.word	0x20000420
 80007e0:	080013c8 	.word	0x080013c8
	...

080007f0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80007f0:	b570      	push	{r4, r5, r6, lr}
 80007f2:	0005      	movs	r5, r0
 80007f4:	000c      	movs	r4, r1
 80007f6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80007f8:	f7ff ffe2 	bl	80007c0 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
 80007fc:	f7ff fd70 	bl	80002e0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000800:	2c00      	cmp	r4, #0
 8000802:	d002      	beq.n	800080a <chCoreAllocAligned+0x1a>
 8000804:	1e63      	subs	r3, r4, #1
 8000806:	4223      	tst	r3, r4
 8000808:	d004      	beq.n	8000814 <chCoreAllocAligned+0x24>
 800080a:	b672      	cpsid	i
 800080c:	4a13      	ldr	r2, [pc, #76]	; (800085c <chCoreAllocAligned+0x6c>)
 800080e:	4b14      	ldr	r3, [pc, #80]	; (8000860 <chCoreAllocAligned+0x70>)
 8000810:	62da      	str	r2, [r3, #44]	; 0x2c
 8000812:	e7fe      	b.n	8000812 <chCoreAllocAligned+0x22>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8000814:	4913      	ldr	r1, [pc, #76]	; (8000864 <chCoreAllocAligned+0x74>)
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000816:	4260      	negs	r0, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8000818:	680a      	ldr	r2, [r1, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800081a:	18eb      	adds	r3, r5, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800081c:	3a01      	subs	r2, #1
 800081e:	1914      	adds	r4, r2, r4

  if (((size_t)endmem - (size_t)p) < size) {
 8000820:	4a11      	ldr	r2, [pc, #68]	; (8000868 <chCoreAllocAligned+0x78>)

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8000822:	4004      	ands	r4, r0

  if (((size_t)endmem - (size_t)p) < size) {
 8000824:	6812      	ldr	r2, [r2, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000826:	4003      	ands	r3, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8000828:	1b12      	subs	r2, r2, r4
 800082a:	4293      	cmp	r3, r2
 800082c:	d80f      	bhi.n	800084e <chCoreAllocAligned+0x5e>
    return NULL;
  }
  nextmem = p + size;
 800082e:	18e3      	adds	r3, r4, r3
 8000830:	600b      	str	r3, [r1, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000832:	f7ff ff95 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000836:	4b0a      	ldr	r3, [pc, #40]	; (8000860 <chCoreAllocAligned+0x70>)
 8000838:	681a      	ldr	r2, [r3, #0]
 800083a:	429a      	cmp	r2, r3
 800083c:	d004      	beq.n	8000848 <chCoreAllocAligned+0x58>
 800083e:	6999      	ldr	r1, [r3, #24]
 8000840:	6892      	ldr	r2, [r2, #8]
 8000842:	6889      	ldr	r1, [r1, #8]
 8000844:	4291      	cmp	r1, r2
 8000846:	d304      	bcc.n	8000852 <chCoreAllocAligned+0x62>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000848:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 800084a:	0020      	movs	r0, r4
 800084c:	bd70      	pop	{r4, r5, r6, pc}

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 800084e:	2400      	movs	r4, #0
 8000850:	e7ef      	b.n	8000832 <chCoreAllocAligned+0x42>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000852:	b672      	cpsid	i
 8000854:	4a05      	ldr	r2, [pc, #20]	; (800086c <chCoreAllocAligned+0x7c>)
 8000856:	62da      	str	r2, [r3, #44]	; 0x2c
 8000858:	e7fe      	b.n	8000858 <chCoreAllocAligned+0x68>
 800085a:	46c0      	nop			; (mov r8, r8)
 800085c:	08001218 	.word	0x08001218
 8000860:	20000420 	.word	0x20000420
 8000864:	20000620 	.word	0x20000620
 8000868:	200004d4 	.word	0x200004d4
 800086c:	08001340 	.word	0x08001340

08000870 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8000870:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000872:	465f      	mov	r7, fp
 8000874:	4656      	mov	r6, sl
 8000876:	464d      	mov	r5, r9
 8000878:	4644      	mov	r4, r8
 800087a:	b4f0      	push	{r4, r5, r6, r7}
 800087c:	b083      	sub	sp, #12
 800087e:	9001      	str	r0, [sp, #4]
 8000880:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000882:	f7ff ff9d 	bl	80007c0 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8000886:	2222      	movs	r2, #34	; 0x22
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8000888:	4cad      	ldr	r4, [pc, #692]	; (8000b40 <chRegFindThreadByWorkingArea+0x2d0>)
 800088a:	6926      	ldr	r6, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 800088c:	5cb3      	ldrb	r3, [r6, r2]
 800088e:	3301      	adds	r3, #1
 8000890:	54b3      	strb	r3, [r6, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000892:	f7ff ff65 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000896:	6823      	ldr	r3, [r4, #0]
 8000898:	42a3      	cmp	r3, r4
 800089a:	d004      	beq.n	80008a6 <chRegFindThreadByWorkingArea+0x36>
 800089c:	69a2      	ldr	r2, [r4, #24]
 800089e:	689b      	ldr	r3, [r3, #8]
 80008a0:	6892      	ldr	r2, [r2, #8]
 80008a2:	429a      	cmp	r2, r3
 80008a4:	d340      	bcc.n	8000928 <chRegFindThreadByWorkingArea+0xb8>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008a6:	b662      	cpsie	i
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80008a8:	9b01      	ldr	r3, [sp, #4]
 80008aa:	69f2      	ldr	r2, [r6, #28]
 80008ac:	4293      	cmp	r3, r2
 80008ae:	d100      	bne.n	80008b2 <chRegFindThreadByWorkingArea+0x42>
 80008b0:	e08b      	b.n	80009ca <chRegFindThreadByWorkingArea+0x15a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008b2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80008b4:	f7ff ff84 	bl	80007c0 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 80008b8:	6933      	ldr	r3, [r6, #16]
 80008ba:	9300      	str	r3, [sp, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80008bc:	42a3      	cmp	r3, r4
 80008be:	d100      	bne.n	80008c2 <chRegFindThreadByWorkingArea+0x52>
 80008c0:	e080      	b.n	80009c4 <chRegFindThreadByWorkingArea+0x154>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80008c2:	2222      	movs	r2, #34	; 0x22
 80008c4:	5c9b      	ldrb	r3, [r3, r2]
 80008c6:	2bff      	cmp	r3, #255	; 0xff
 80008c8:	d100      	bne.n	80008cc <chRegFindThreadByWorkingArea+0x5c>
 80008ca:	e077      	b.n	80009bc <chRegFindThreadByWorkingArea+0x14c>
    ntp->refs++;
 80008cc:	9900      	ldr	r1, [sp, #0]
 80008ce:	3301      	adds	r3, #1
 80008d0:	548b      	strb	r3, [r1, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80008d2:	f7ff ff45 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80008d6:	6823      	ldr	r3, [r4, #0]
 80008d8:	42a3      	cmp	r3, r4
 80008da:	d004      	beq.n	80008e6 <chRegFindThreadByWorkingArea+0x76>
 80008dc:	69a2      	ldr	r2, [r4, #24]
 80008de:	689b      	ldr	r3, [r3, #8]
 80008e0:	6892      	ldr	r2, [r2, #8]
 80008e2:	429a      	cmp	r2, r3
 80008e4:	d324      	bcc.n	8000930 <chRegFindThreadByWorkingArea+0xc0>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008e6:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008e8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80008ea:	f7ff ff69 	bl	80007c0 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80008ee:	2222      	movs	r2, #34	; 0x22
 80008f0:	5cb3      	ldrb	r3, [r6, r2]
 80008f2:	2b00      	cmp	r3, #0
 80008f4:	d100      	bne.n	80008f8 <chRegFindThreadByWorkingArea+0x88>
 80008f6:	e074      	b.n	80009e2 <chRegFindThreadByWorkingArea+0x172>
  tp->refs--;
 80008f8:	3b01      	subs	r3, #1
 80008fa:	54b3      	strb	r3, [r6, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80008fc:	6a32      	ldr	r2, [r6, #32]
 80008fe:	4b91      	ldr	r3, [pc, #580]	; (8000b44 <chRegFindThreadByWorkingArea+0x2d4>)
 8000900:	4013      	ands	r3, r2
 8000902:	2b0f      	cmp	r3, #15
 8000904:	d018      	beq.n	8000938 <chRegFindThreadByWorkingArea+0xc8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000906:	f7ff ff2b 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800090a:	6823      	ldr	r3, [r4, #0]
 800090c:	42a3      	cmp	r3, r4
 800090e:	d004      	beq.n	800091a <chRegFindThreadByWorkingArea+0xaa>
 8000910:	69a2      	ldr	r2, [r4, #24]
 8000912:	689b      	ldr	r3, [r3, #8]
 8000914:	6892      	ldr	r2, [r2, #8]
 8000916:	429a      	cmp	r2, r3
 8000918:	d35f      	bcc.n	80009da <chRegFindThreadByWorkingArea+0x16a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800091a:	b662      	cpsie	i
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 800091c:	9b00      	ldr	r3, [sp, #0]
 800091e:	2b00      	cmp	r3, #0
 8000920:	d100      	bne.n	8000924 <chRegFindThreadByWorkingArea+0xb4>
 8000922:	e1a6      	b.n	8000c72 <chRegFindThreadByWorkingArea+0x402>
 8000924:	9e00      	ldr	r6, [sp, #0]
 8000926:	e7bf      	b.n	80008a8 <chRegFindThreadByWorkingArea+0x38>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000928:	b672      	cpsid	i
 800092a:	4b87      	ldr	r3, [pc, #540]	; (8000b48 <chRegFindThreadByWorkingArea+0x2d8>)
 800092c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800092e:	e7fe      	b.n	800092e <chRegFindThreadByWorkingArea+0xbe>
 8000930:	b672      	cpsid	i
 8000932:	4b85      	ldr	r3, [pc, #532]	; (8000b48 <chRegFindThreadByWorkingArea+0x2d8>)
 8000934:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000936:	e7fe      	b.n	8000936 <chRegFindThreadByWorkingArea+0xc6>
    REG_REMOVE(tp);
 8000938:	6973      	ldr	r3, [r6, #20]
 800093a:	6932      	ldr	r2, [r6, #16]
 800093c:	611a      	str	r2, [r3, #16]
 800093e:	6932      	ldr	r2, [r6, #16]
 8000940:	6153      	str	r3, [r2, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000942:	f7ff ff0d 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000946:	6823      	ldr	r3, [r4, #0]
 8000948:	42a3      	cmp	r3, r4
 800094a:	d004      	beq.n	8000956 <chRegFindThreadByWorkingArea+0xe6>
 800094c:	69a2      	ldr	r2, [r4, #24]
 800094e:	689b      	ldr	r3, [r3, #8]
 8000950:	6892      	ldr	r2, [r2, #8]
 8000952:	429a      	cmp	r2, r3
 8000954:	d349      	bcc.n	80009ea <chRegFindThreadByWorkingArea+0x17a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000956:	b662      	cpsie	i
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8000958:	2321      	movs	r3, #33	; 0x21
 800095a:	2203      	movs	r2, #3
 800095c:	5cf3      	ldrb	r3, [r6, r3]
 800095e:	4013      	ands	r3, r2
 8000960:	2b01      	cmp	r3, #1
 8000962:	d021      	beq.n	80009a8 <chRegFindThreadByWorkingArea+0x138>
 8000964:	2b02      	cmp	r3, #2
 8000966:	d1d9      	bne.n	800091c <chRegFindThreadByWorkingArea+0xac>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8000968:	6c35      	ldr	r5, [r6, #64]	; 0x40
 800096a:	69f6      	ldr	r6, [r6, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800096c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800096e:	f7ff ff27 	bl	80007c0 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8000972:	f7ff fcb5 	bl	80002e0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8000976:	2d00      	cmp	r5, #0
 8000978:	d012      	beq.n	80009a0 <chRegFindThreadByWorkingArea+0x130>
 800097a:	2e00      	cmp	r6, #0
 800097c:	d010      	beq.n	80009a0 <chRegFindThreadByWorkingArea+0x130>

  php->next = mp->next;
 800097e:	682b      	ldr	r3, [r5, #0]
 8000980:	6033      	str	r3, [r6, #0]
  mp->next = php;
 8000982:	602e      	str	r6, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000984:	f7ff feec 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000988:	6823      	ldr	r3, [r4, #0]
 800098a:	42a3      	cmp	r3, r4
 800098c:	d0c5      	beq.n	800091a <chRegFindThreadByWorkingArea+0xaa>
 800098e:	69a2      	ldr	r2, [r4, #24]
 8000990:	689b      	ldr	r3, [r3, #8]
 8000992:	6892      	ldr	r2, [r2, #8]
 8000994:	429a      	cmp	r2, r3
 8000996:	d2c0      	bcs.n	800091a <chRegFindThreadByWorkingArea+0xaa>
 8000998:	b672      	cpsid	i
 800099a:	4b6c      	ldr	r3, [pc, #432]	; (8000b4c <chRegFindThreadByWorkingArea+0x2dc>)
 800099c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800099e:	e7fe      	b.n	800099e <chRegFindThreadByWorkingArea+0x12e>
 80009a0:	b672      	cpsid	i
 80009a2:	4b6b      	ldr	r3, [pc, #428]	; (8000b50 <chRegFindThreadByWorkingArea+0x2e0>)
 80009a4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009a6:	e7fe      	b.n	80009a6 <chRegFindThreadByWorkingArea+0x136>
 80009a8:	69f5      	ldr	r5, [r6, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80009aa:	2d00      	cmp	r5, #0
 80009ac:	d002      	beq.n	80009b4 <chRegFindThreadByWorkingArea+0x144>
 80009ae:	2307      	movs	r3, #7
 80009b0:	421d      	tst	r5, r3
 80009b2:	d01e      	beq.n	80009f2 <chRegFindThreadByWorkingArea+0x182>
 80009b4:	b672      	cpsid	i
 80009b6:	4b67      	ldr	r3, [pc, #412]	; (8000b54 <chRegFindThreadByWorkingArea+0x2e4>)
 80009b8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009ba:	e7fe      	b.n	80009ba <chRegFindThreadByWorkingArea+0x14a>
 80009bc:	b672      	cpsid	i
 80009be:	4b66      	ldr	r3, [pc, #408]	; (8000b58 <chRegFindThreadByWorkingArea+0x2e8>)
 80009c0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009c2:	e7fe      	b.n	80009c2 <chRegFindThreadByWorkingArea+0x152>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 80009c4:	2300      	movs	r3, #0
 80009c6:	9300      	str	r3, [sp, #0]
 80009c8:	e783      	b.n	80008d2 <chRegFindThreadByWorkingArea+0x62>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80009ca:	0030      	movs	r0, r6
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
 80009cc:	b003      	add	sp, #12
 80009ce:	bc3c      	pop	{r2, r3, r4, r5}
 80009d0:	4690      	mov	r8, r2
 80009d2:	4699      	mov	r9, r3
 80009d4:	46a2      	mov	sl, r4
 80009d6:	46ab      	mov	fp, r5
 80009d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80009da:	b672      	cpsid	i
 80009dc:	4b5f      	ldr	r3, [pc, #380]	; (8000b5c <chRegFindThreadByWorkingArea+0x2ec>)
 80009de:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009e0:	e7fe      	b.n	80009e0 <chRegFindThreadByWorkingArea+0x170>
 80009e2:	b672      	cpsid	i
 80009e4:	4b5e      	ldr	r3, [pc, #376]	; (8000b60 <chRegFindThreadByWorkingArea+0x2f0>)
 80009e6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009e8:	e7fe      	b.n	80009e8 <chRegFindThreadByWorkingArea+0x178>
 80009ea:	b672      	cpsid	i
 80009ec:	4b5b      	ldr	r3, [pc, #364]	; (8000b5c <chRegFindThreadByWorkingArea+0x2ec>)
 80009ee:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009f0:	e7fe      	b.n	80009f0 <chRegFindThreadByWorkingArea+0x180>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80009f2:	2308      	movs	r3, #8
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80009f4:	3d08      	subs	r5, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80009f6:	682e      	ldr	r6, [r5, #0]
  qp = &heapp->header;
 80009f8:	4699      	mov	r9, r3
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80009fa:	0037      	movs	r7, r6
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80009fc:	686b      	ldr	r3, [r5, #4]

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80009fe:	44b1      	add	r9, r6

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8000a00:	3307      	adds	r3, #7
 8000a02:	08db      	lsrs	r3, r3, #3
 8000a04:	606b      	str	r3, [r5, #4]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8000a06:	3710      	adds	r7, #16
 8000a08:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000a0a:	f7ff fed9 	bl	80007c0 <_dbg_check_lock>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000a0e:	69a3      	ldr	r3, [r4, #24]
 8000a10:	469a      	mov	sl, r3

  chDbgCheckClassS();
 8000a12:	f7ff fc55 	bl	80002c0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8000a16:	2f00      	cmp	r7, #0
 8000a18:	d100      	bne.n	8000a1c <chRegFindThreadByWorkingArea+0x1ac>
 8000a1a:	e126      	b.n	8000c6a <chRegFindThreadByWorkingArea+0x3fa>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000a1c:	69b0      	ldr	r0, [r6, #24]
 8000a1e:	2800      	cmp	r0, #0
 8000a20:	d037      	beq.n	8000a92 <chRegFindThreadByWorkingArea+0x222>
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000a22:	2320      	movs	r3, #32
 8000a24:	469c      	mov	ip, r3
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000a26:	4653      	mov	r3, sl
 8000a28:	689a      	ldr	r2, [r3, #8]
 8000a2a:	6883      	ldr	r3, [r0, #8]
 8000a2c:	429a      	cmp	r2, r3
 8000a2e:	d914      	bls.n	8000a5a <chRegFindThreadByWorkingArea+0x1ea>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000a30:	4663      	mov	r3, ip

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8000a32:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000a34:	5cc3      	ldrb	r3, [r0, r3]
 8000a36:	2b06      	cmp	r3, #6
 8000a38:	d100      	bne.n	8000a3c <chRegFindThreadByWorkingArea+0x1cc>
 8000a3a:	e101      	b.n	8000c40 <chRegFindThreadByWorkingArea+0x3d0>
 8000a3c:	2b07      	cmp	r3, #7
 8000a3e:	d100      	bne.n	8000a42 <chRegFindThreadByWorkingArea+0x1d2>
 8000a40:	e0ea      	b.n	8000c18 <chRegFindThreadByWorkingArea+0x3a8>
 8000a42:	2b00      	cmp	r3, #0
 8000a44:	d109      	bne.n	8000a5a <chRegFindThreadByWorkingArea+0x1ea>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8000a46:	2201      	movs	r2, #1
 8000a48:	2320      	movs	r3, #32
 8000a4a:	54c2      	strb	r2, [r0, r3]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000a4c:	6802      	ldr	r2, [r0, #0]
 8000a4e:	6843      	ldr	r3, [r0, #4]
 8000a50:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000a52:	6802      	ldr	r2, [r0, #0]
 8000a54:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000a56:	f7ff fc53 	bl	8000300 <chSchReadyI>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000a5a:	003b      	movs	r3, r7
 8000a5c:	4652      	mov	r2, sl
  do {
    cp = cp->queue.next;
 8000a5e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000a60:	429f      	cmp	r7, r3
 8000a62:	d003      	beq.n	8000a6c <chRegFindThreadByWorkingArea+0x1fc>
 8000a64:	6899      	ldr	r1, [r3, #8]
 8000a66:	6890      	ldr	r0, [r2, #8]
 8000a68:	4281      	cmp	r1, r0
 8000a6a:	d2f8      	bcs.n	8000a5e <chRegFindThreadByWorkingArea+0x1ee>
 8000a6c:	4692      	mov	sl, r2
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000a6e:	4651      	mov	r1, sl

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000a70:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8000a72:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000a74:	2006      	movs	r0, #6
 8000a76:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000a78:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8000a7a:	6059      	str	r1, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8000a7c:	624f      	str	r7, [r1, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8000a7e:	f7ff fd47 	bl	8000510 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8000a82:	69b3      	ldr	r3, [r6, #24]
 8000a84:	459a      	cmp	sl, r3
 8000a86:	d100      	bne.n	8000a8a <chRegFindThreadByWorkingArea+0x21a>
 8000a88:	e0f5      	b.n	8000c76 <chRegFindThreadByWorkingArea+0x406>
 8000a8a:	b672      	cpsid	i
 8000a8c:	4b35      	ldr	r3, [pc, #212]	; (8000b64 <chRegFindThreadByWorkingArea+0x2f4>)
 8000a8e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000a90:	e7fe      	b.n	8000a90 <chRegFindThreadByWorkingArea+0x220>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8000a92:	4653      	mov	r3, sl
 8000a94:	61b3      	str	r3, [r6, #24]
    mp->next = ctp->mtxlist;
 8000a96:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000a98:	61f3      	str	r3, [r6, #28]
    ctp->mtxlist = mp;
 8000a9a:	4653      	mov	r3, sl
 8000a9c:	639f      	str	r7, [r3, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000a9e:	f7ff fe5f 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000aa2:	6823      	ldr	r3, [r4, #0]
 8000aa4:	42a3      	cmp	r3, r4
 8000aa6:	d005      	beq.n	8000ab4 <chRegFindThreadByWorkingArea+0x244>
 8000aa8:	69a2      	ldr	r2, [r4, #24]
 8000aaa:	689b      	ldr	r3, [r3, #8]
 8000aac:	6892      	ldr	r2, [r2, #8]
 8000aae:	429a      	cmp	r2, r3
 8000ab0:	d200      	bcs.n	8000ab4 <chRegFindThreadByWorkingArea+0x244>
 8000ab2:	e0ed      	b.n	8000c90 <chRegFindThreadByWorkingArea+0x420>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ab4:	b662      	cpsie	i

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8000ab6:	464b      	mov	r3, r9
 8000ab8:	4649      	mov	r1, r9

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8000aba:	429d      	cmp	r5, r3
 8000abc:	d306      	bcc.n	8000acc <chRegFindThreadByWorkingArea+0x25c>
 8000abe:	685a      	ldr	r2, [r3, #4]
 8000ac0:	3201      	adds	r2, #1
 8000ac2:	00d2      	lsls	r2, r2, #3
 8000ac4:	189a      	adds	r2, r3, r2
 8000ac6:	4295      	cmp	r5, r2
 8000ac8:	d200      	bcs.n	8000acc <chRegFindThreadByWorkingArea+0x25c>
 8000aca:	e0dd      	b.n	8000c88 <chRegFindThreadByWorkingArea+0x418>

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8000acc:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8000ace:	4299      	cmp	r1, r3
 8000ad0:	d001      	beq.n	8000ad6 <chRegFindThreadByWorkingArea+0x266>
 8000ad2:	429d      	cmp	r5, r3
 8000ad4:	d903      	bls.n	8000ade <chRegFindThreadByWorkingArea+0x26e>
 8000ad6:	2a00      	cmp	r2, #0
 8000ad8:	d003      	beq.n	8000ae2 <chRegFindThreadByWorkingArea+0x272>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8000ada:	4295      	cmp	r5, r2
 8000adc:	d301      	bcc.n	8000ae2 <chRegFindThreadByWorkingArea+0x272>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8000ade:	0013      	movs	r3, r2
 8000ae0:	e7eb      	b.n	8000aba <chRegFindThreadByWorkingArea+0x24a>
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8000ae2:	602a      	str	r2, [r5, #0]
      H_NEXT(qp) = hp;
 8000ae4:	601d      	str	r5, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8000ae6:	6869      	ldr	r1, [r5, #4]
 8000ae8:	6828      	ldr	r0, [r5, #0]
 8000aea:	1c4a      	adds	r2, r1, #1
 8000aec:	00d2      	lsls	r2, r2, #3
 8000aee:	18aa      	adds	r2, r5, r2
 8000af0:	4282      	cmp	r2, r0
 8000af2:	d106      	bne.n	8000b02 <chRegFindThreadByWorkingArea+0x292>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8000af4:	6850      	ldr	r0, [r2, #4]
 8000af6:	4684      	mov	ip, r0
 8000af8:	4461      	add	r1, ip
 8000afa:	3101      	adds	r1, #1
 8000afc:	6069      	str	r1, [r5, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8000afe:	6812      	ldr	r2, [r2, #0]
 8000b00:	602a      	str	r2, [r5, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8000b02:	6859      	ldr	r1, [r3, #4]
 8000b04:	1c4a      	adds	r2, r1, #1
 8000b06:	00d2      	lsls	r2, r2, #3
 8000b08:	189a      	adds	r2, r3, r2
 8000b0a:	4295      	cmp	r5, r2
 8000b0c:	d100      	bne.n	8000b10 <chRegFindThreadByWorkingArea+0x2a0>
 8000b0e:	e07a      	b.n	8000c06 <chRegFindThreadByWorkingArea+0x396>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000b10:	69a3      	ldr	r3, [r4, #24]
 8000b12:	469a      	mov	sl, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b14:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000b16:	f7ff fe53 	bl	80007c0 <_dbg_check_lock>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8000b1a:	4653      	mov	r3, sl
 8000b1c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000b1e:	2b00      	cmp	r3, #0
 8000b20:	d06d      	beq.n	8000bfe <chRegFindThreadByWorkingArea+0x38e>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8000b22:	689a      	ldr	r2, [r3, #8]
 8000b24:	4693      	mov	fp, r2
 8000b26:	4552      	cmp	r2, sl
 8000b28:	d003      	beq.n	8000b32 <chRegFindThreadByWorkingArea+0x2c2>
 8000b2a:	b672      	cpsid	i
 8000b2c:	4b0e      	ldr	r3, [pc, #56]	; (8000b68 <chRegFindThreadByWorkingArea+0x2f8>)
 8000b2e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000b30:	e7fe      	b.n	8000b30 <chRegFindThreadByWorkingArea+0x2c0>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8000b32:	429f      	cmp	r7, r3
 8000b34:	d01a      	beq.n	8000b6c <chRegFindThreadByWorkingArea+0x2fc>
 8000b36:	b672      	cpsid	i
 8000b38:	4b0b      	ldr	r3, [pc, #44]	; (8000b68 <chRegFindThreadByWorkingArea+0x2f8>)
 8000b3a:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000b3c:	e7fe      	b.n	8000b3c <chRegFindThreadByWorkingArea+0x2cc>
 8000b3e:	46c0      	nop			; (mov r8, r8)
 8000b40:	20000420 	.word	0x20000420
 8000b44:	00ff00ff 	.word	0x00ff00ff
 8000b48:	080011f4 	.word	0x080011f4
 8000b4c:	0800134c 	.word	0x0800134c
 8000b50:	08001264 	.word	0x08001264
 8000b54:	080012f0 	.word	0x080012f0
 8000b58:	080011e4 	.word	0x080011e4
 8000b5c:	08001358 	.word	0x08001358
 8000b60:	08001324 	.word	0x08001324
 8000b64:	0800120c 	.word	0x0800120c
 8000b68:	08001258 	.word	0x08001258

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000b6c:	69f3      	ldr	r3, [r6, #28]
 8000b6e:	4699      	mov	r9, r3
 8000b70:	4653      	mov	r3, sl
 8000b72:	464a      	mov	r2, r9
 8000b74:	639a      	str	r2, [r3, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8000b76:	f7ff fba3 	bl	80002c0 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000b7a:	6935      	ldr	r5, [r6, #16]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000b7c:	42af      	cmp	r7, r5
 8000b7e:	d03b      	beq.n	8000bf8 <chRegFindThreadByWorkingArea+0x388>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000b80:	4653      	mov	r3, sl
 8000b82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000b84:	46a8      	mov	r8, r5
 8000b86:	469a      	mov	sl, r3
 8000b88:	464d      	mov	r5, r9
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000b8a:	2d00      	cmp	r5, #0
 8000b8c:	d00a      	beq.n	8000ba4 <chRegFindThreadByWorkingArea+0x334>
 8000b8e:	f7ff fb97 	bl	80002c0 <chDbgCheckClassS>
 8000b92:	682b      	ldr	r3, [r5, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000b94:	429d      	cmp	r5, r3
 8000b96:	d003      	beq.n	8000ba0 <chRegFindThreadByWorkingArea+0x330>
            (lmp->queue.next->prio > newprio)) {
 8000b98:	689b      	ldr	r3, [r3, #8]
 8000b9a:	459a      	cmp	sl, r3
 8000b9c:	d200      	bcs.n	8000ba0 <chRegFindThreadByWorkingArea+0x330>
 8000b9e:	469a      	mov	sl, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000ba0:	68ed      	ldr	r5, [r5, #12]
 8000ba2:	e7f2      	b.n	8000b8a <chRegFindThreadByWorkingArea+0x31a>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8000ba4:	4652      	mov	r2, sl
 8000ba6:	4645      	mov	r5, r8
 8000ba8:	465b      	mov	r3, fp
 8000baa:	609a      	str	r2, [r3, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000bac:	682b      	ldr	r3, [r5, #0]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000bae:	4640      	mov	r0, r8
 8000bb0:	6133      	str	r3, [r6, #16]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000bb2:	605f      	str	r7, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000bb4:	6bab      	ldr	r3, [r5, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8000bb6:	61b5      	str	r5, [r6, #24]
      mp->next = tp->mtxlist;
 8000bb8:	61f3      	str	r3, [r6, #28]
      tp->mtxlist = mp;
 8000bba:	63af      	str	r7, [r5, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000bbc:	f7ff fba0 	bl	8000300 <chSchReadyI>
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
 8000bc0:	f7ff fb7e 	bl	80002c0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8000bc4:	f7ff fb8c 	bl	80002e0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000bc8:	6822      	ldr	r2, [r4, #0]
 8000bca:	69a3      	ldr	r3, [r4, #24]

  if (chSchIsRescRequiredI()) {
 8000bcc:	6892      	ldr	r2, [r2, #8]
 8000bce:	689b      	ldr	r3, [r3, #8]
 8000bd0:	429a      	cmp	r2, r3
 8000bd2:	d901      	bls.n	8000bd8 <chRegFindThreadByWorkingArea+0x368>
    chSchDoRescheduleAhead();
 8000bd4:	f7ff fd7c 	bl	80006d0 <chSchDoReschedule>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000bd8:	f7ff fdc2 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000bdc:	6823      	ldr	r3, [r4, #0]
 8000bde:	42a3      	cmp	r3, r4
 8000be0:	d100      	bne.n	8000be4 <chRegFindThreadByWorkingArea+0x374>
 8000be2:	e69a      	b.n	800091a <chRegFindThreadByWorkingArea+0xaa>
 8000be4:	69a2      	ldr	r2, [r4, #24]
 8000be6:	689b      	ldr	r3, [r3, #8]
 8000be8:	6892      	ldr	r2, [r2, #8]
 8000bea:	429a      	cmp	r2, r3
 8000bec:	d300      	bcc.n	8000bf0 <chRegFindThreadByWorkingArea+0x380>
 8000bee:	e694      	b.n	800091a <chRegFindThreadByWorkingArea+0xaa>
 8000bf0:	b672      	cpsid	i
 8000bf2:	4b29      	ldr	r3, [pc, #164]	; (8000c98 <chRegFindThreadByWorkingArea+0x428>)
 8000bf4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000bf6:	e7fe      	b.n	8000bf6 <chRegFindThreadByWorkingArea+0x386>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8000bf8:	2300      	movs	r3, #0
 8000bfa:	61b3      	str	r3, [r6, #24]
 8000bfc:	e7ec      	b.n	8000bd8 <chRegFindThreadByWorkingArea+0x368>
 8000bfe:	b672      	cpsid	i
 8000c00:	4b26      	ldr	r3, [pc, #152]	; (8000c9c <chRegFindThreadByWorkingArea+0x42c>)
 8000c02:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000c04:	e7fe      	b.n	8000c04 <chRegFindThreadByWorkingArea+0x394>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8000c06:	686a      	ldr	r2, [r5, #4]
 8000c08:	188a      	adds	r2, r1, r2
 8000c0a:	3201      	adds	r2, #1
 8000c0c:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8000c0e:	682a      	ldr	r2, [r5, #0]
 8000c10:	601a      	str	r2, [r3, #0]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000c12:	69a3      	ldr	r3, [r4, #24]
 8000c14:	469a      	mov	sl, r3
 8000c16:	e77d      	b.n	8000b14 <chRegFindThreadByWorkingArea+0x2a4>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000c18:	6843      	ldr	r3, [r0, #4]
 8000c1a:	6801      	ldr	r1, [r0, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000c1c:	4694      	mov	ip, r2
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000c1e:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c20:	6801      	ldr	r1, [r0, #0]
 8000c22:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000c24:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000c26:	000b      	movs	r3, r1
  do {
    cp = cp->queue.next;
 8000c28:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000c2a:	4299      	cmp	r1, r3
 8000c2c:	d002      	beq.n	8000c34 <chRegFindThreadByWorkingArea+0x3c4>
 8000c2e:	689a      	ldr	r2, [r3, #8]
 8000c30:	4594      	cmp	ip, r2
 8000c32:	d9f9      	bls.n	8000c28 <chRegFindThreadByWorkingArea+0x3b8>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000c34:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000c36:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000c38:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000c3a:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c3c:	6058      	str	r0, [r3, #4]
 8000c3e:	e70c      	b.n	8000a5a <chRegFindThreadByWorkingArea+0x1ea>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000c40:	6841      	ldr	r1, [r0, #4]
 8000c42:	6803      	ldr	r3, [r0, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000c44:	4690      	mov	r8, r2
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000c46:	600b      	str	r3, [r1, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c48:	6803      	ldr	r3, [r0, #0]
 8000c4a:	6059      	str	r1, [r3, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000c4c:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000c4e:	000b      	movs	r3, r1
  do {
    cp = cp->queue.next;
 8000c50:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000c52:	4299      	cmp	r1, r3
 8000c54:	d002      	beq.n	8000c5c <chRegFindThreadByWorkingArea+0x3ec>
 8000c56:	689a      	ldr	r2, [r3, #8]
 8000c58:	4590      	cmp	r8, r2
 8000c5a:	d9f9      	bls.n	8000c50 <chRegFindThreadByWorkingArea+0x3e0>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000c5c:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000c5e:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000c60:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000c62:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c64:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8000c66:	6888      	ldr	r0, [r1, #8]
 8000c68:	e6dd      	b.n	8000a26 <chRegFindThreadByWorkingArea+0x1b6>
 8000c6a:	b672      	cpsid	i
 8000c6c:	4b0c      	ldr	r3, [pc, #48]	; (8000ca0 <chRegFindThreadByWorkingArea+0x430>)
 8000c6e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000c70:	e7fe      	b.n	8000c70 <chRegFindThreadByWorkingArea+0x400>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
 8000c72:	0018      	movs	r0, r3
 8000c74:	e6aa      	b.n	80009cc <chRegFindThreadByWorkingArea+0x15c>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8000c76:	4653      	mov	r3, sl
 8000c78:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000c7a:	429f      	cmp	r7, r3
 8000c7c:	d100      	bne.n	8000c80 <chRegFindThreadByWorkingArea+0x410>
 8000c7e:	e70e      	b.n	8000a9e <chRegFindThreadByWorkingArea+0x22e>
 8000c80:	b672      	cpsid	i
 8000c82:	4b07      	ldr	r3, [pc, #28]	; (8000ca0 <chRegFindThreadByWorkingArea+0x430>)
 8000c84:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000c86:	e7fe      	b.n	8000c86 <chRegFindThreadByWorkingArea+0x416>
 8000c88:	b672      	cpsid	i
 8000c8a:	4b06      	ldr	r3, [pc, #24]	; (8000ca4 <chRegFindThreadByWorkingArea+0x434>)
 8000c8c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000c8e:	e7fe      	b.n	8000c8e <chRegFindThreadByWorkingArea+0x41e>
 8000c90:	b672      	cpsid	i
 8000c92:	4b01      	ldr	r3, [pc, #4]	; (8000c98 <chRegFindThreadByWorkingArea+0x428>)
 8000c94:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000c96:	e7fe      	b.n	8000c96 <chRegFindThreadByWorkingArea+0x426>
 8000c98:	08001334 	.word	0x08001334
 8000c9c:	08001258 	.word	0x08001258
 8000ca0:	0800120c 	.word	0x0800120c
 8000ca4:	080012f0 	.word	0x080012f0
	...

08000cb0 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000cb0:	4bdf      	ldr	r3, [pc, #892]	; (8001030 <main+0x380>)
 8000cb2:	2101      	movs	r1, #1
 8000cb4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
}

/*
 * Application entry point.
 */
int main(void) {
 8000cb6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cb8:	2200      	movs	r2, #0
 8000cba:	464f      	mov	r7, r9
 8000cbc:	4646      	mov	r6, r8
 8000cbe:	4249      	negs	r1, r1
 8000cc0:	b4c0      	push	{r6, r7}
 8000cc2:	6299      	str	r1, [r3, #40]	; 0x28
 8000cc4:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000cc6:	6918      	ldr	r0, [r3, #16]
 8000cc8:	6119      	str	r1, [r3, #16]
 8000cca:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000ccc:	68d9      	ldr	r1, [r3, #12]
 8000cce:	48d9      	ldr	r0, [pc, #868]	; (8001034 <main+0x384>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000cd0:	2480      	movs	r4, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000cd2:	4301      	orrs	r1, r0

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000cd4:	2080      	movs	r0, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000cd6:	60d9      	str	r1, [r3, #12]
 8000cd8:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000cda:	69d9      	ldr	r1, [r3, #28]
 8000cdc:	0540      	lsls	r0, r0, #21
 8000cde:	4301      	orrs	r1, r0
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000ce0:	48d5      	ldr	r0, [pc, #852]	; (8001038 <main+0x388>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000ce2:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000ce4:	6801      	ldr	r1, [r0, #0]
 8000ce6:	0064      	lsls	r4, r4, #1
 8000ce8:	4321      	orrs	r1, r4
 8000cea:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8000cec:	21c0      	movs	r1, #192	; 0xc0
 8000cee:	6a18      	ldr	r0, [r3, #32]
 8000cf0:	0089      	lsls	r1, r1, #2
 8000cf2:	4001      	ands	r1, r0
 8000cf4:	2080      	movs	r0, #128	; 0x80
 8000cf6:	b087      	sub	sp, #28
 8000cf8:	0080      	lsls	r0, r0, #2
 8000cfa:	4281      	cmp	r1, r0
 8000cfc:	d003      	beq.n	8000d06 <main+0x56>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000cfe:	2180      	movs	r1, #128	; 0x80
 8000d00:	0249      	lsls	r1, r1, #9
 8000d02:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8000d04:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000d06:	2080      	movs	r0, #128	; 0x80
 8000d08:	4bc9      	ldr	r3, [pc, #804]	; (8001030 <main+0x380>)
 8000d0a:	0200      	lsls	r0, r0, #8
 8000d0c:	6a1a      	ldr	r2, [r3, #32]
 8000d0e:	4202      	tst	r2, r0
 8000d10:	d107      	bne.n	8000d22 <main+0x72>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000d12:	2280      	movs	r2, #128	; 0x80
 8000d14:	6a19      	ldr	r1, [r3, #32]
 8000d16:	0092      	lsls	r2, r2, #2
 8000d18:	4311      	orrs	r1, r2
 8000d1a:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000d1c:	6a1a      	ldr	r2, [r3, #32]
 8000d1e:	4302      	orrs	r2, r0
 8000d20:	621a      	str	r2, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000d22:	219c      	movs	r1, #156	; 0x9c
 8000d24:	4ac2      	ldr	r2, [pc, #776]	; (8001030 <main+0x380>)
 8000d26:	03c9      	lsls	r1, r1, #15
 8000d28:	6953      	ldr	r3, [r2, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000d2a:	48c4      	ldr	r0, [pc, #784]	; (800103c <main+0x38c>)
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000d2c:	430b      	orrs	r3, r1
 8000d2e:	6153      	str	r3, [r2, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000d30:	2101      	movs	r1, #1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d32:	2290      	movs	r2, #144	; 0x90
 8000d34:	2300      	movs	r3, #0
 8000d36:	05d2      	lsls	r2, r2, #23
  gpiop->OSPEEDR = config->ospeedr;
 8000d38:	4249      	negs	r1, r1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d3a:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000d3c:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000d3e:	60d0      	str	r0, [r2, #12]
  gpiop->ODR     = config->odr;
 8000d40:	48bf      	ldr	r0, [pc, #764]	; (8001040 <main+0x390>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000d42:	2480      	movs	r4, #128	; 0x80
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000d44:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000d46:	48bf      	ldr	r0, [pc, #764]	; (8001044 <main+0x394>)
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000d48:	02a4      	lsls	r4, r4, #10

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000d4a:	6210      	str	r0, [r2, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000d4c:	48be      	ldr	r0, [pc, #760]	; (8001048 <main+0x398>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8000d4e:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000d50:	6010      	str	r0, [r2, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000d52:	20c0      	movs	r0, #192	; 0xc0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d54:	4abd      	ldr	r2, [pc, #756]	; (800104c <main+0x39c>)
  gpiop->OSPEEDR = config->ospeedr;
 8000d56:	0280      	lsls	r0, r0, #10
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d58:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000d5a:	6090      	str	r0, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000d5c:	48bc      	ldr	r0, [pc, #752]	; (8001050 <main+0x3a0>)
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8000d5e:	2501      	movs	r5, #1
 8000d60:	60d0      	str	r0, [r2, #12]
  gpiop->ODR     = config->odr;
 8000d62:	48bc      	ldr	r0, [pc, #752]	; (8001054 <main+0x3a4>)
 8000d64:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000d66:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000d68:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000d6a:	6014      	str	r4, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d6c:	4aba      	ldr	r2, [pc, #744]	; (8001058 <main+0x3a8>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000d6e:	4cbb      	ldr	r4, [pc, #748]	; (800105c <main+0x3ac>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d70:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000d72:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000d74:	60d4      	str	r4, [r2, #12]
  gpiop->ODR     = config->odr;
 8000d76:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000d78:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000d7a:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000d7c:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000d7e:	4ab8      	ldr	r2, [pc, #736]	; (8001060 <main+0x3b0>)
 8000d80:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000d82:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000d84:	60d4      	str	r4, [r2, #12]

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
  PWMD2.tim = STM32_TIM2;
 8000d86:	2480      	movs	r4, #128	; 0x80
  gpiop->ODR     = config->odr;
 8000d88:	6150      	str	r0, [r2, #20]
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
 8000d8a:	2004      	movs	r0, #4
  gpiop->AFRL    = config->afrl;
 8000d8c:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000d8e:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000d90:	6013      	str	r3, [r2, #0]
 8000d92:	4ab4      	ldr	r2, [pc, #720]	; (8001064 <main+0x3b4>)
  PWMD2.tim = STM32_TIM2;
 8000d94:	05e4      	lsls	r4, r4, #23
 8000d96:	7015      	strb	r5, [r2, #0]
  pwmp->config   = NULL;
 8000d98:	6053      	str	r3, [r2, #4]
  pwmp->enabled  = 0;
 8000d9a:	60d3      	str	r3, [r2, #12]
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
 8000d9c:	7410      	strb	r0, [r2, #16]
  PWMD2.tim = STM32_TIM2;
 8000d9e:	6194      	str	r4, [r2, #24]
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8000da0:	4ab1      	ldr	r2, [pc, #708]	; (8001068 <main+0x3b8>)
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {

  osalDbgCheck(handler < 12U);

#if defined(__CORE_CM0_H_GENERIC)
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
 8000da2:	2480      	movs	r4, #128	; 0x80
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8000da4:	7410      	strb	r0, [r2, #16]
  PWMD3.tim = STM32_TIM3;
 8000da6:	48b1      	ldr	r0, [pc, #708]	; (800106c <main+0x3bc>)
 8000da8:	7015      	strb	r5, [r2, #0]
  pwmp->config   = NULL;
 8000daa:	6053      	str	r3, [r2, #4]
  pwmp->enabled  = 0;
 8000dac:	60d3      	str	r3, [r2, #12]
 8000dae:	6190      	str	r0, [r2, #24]
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8000db0:	4aaf      	ldr	r2, [pc, #700]	; (8001070 <main+0x3c0>)
 8000db2:	48b0      	ldr	r0, [pc, #704]	; (8001074 <main+0x3c4>)
 8000db4:	0624      	lsls	r4, r4, #24
 8000db6:	6050      	str	r0, [r2, #4]
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8000db8:	2007      	movs	r0, #7

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
 8000dba:	6093      	str	r3, [r2, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8000dbc:	6010      	str	r0, [r2, #0]
 8000dbe:	48ae      	ldr	r0, [pc, #696]	; (8001078 <main+0x3c8>)
 8000dc0:	69c2      	ldr	r2, [r0, #28]
 8000dc2:	0212      	lsls	r2, r2, #8
 8000dc4:	0a12      	lsrs	r2, r2, #8
 8000dc6:	4322      	orrs	r2, r4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000dc8:	4cac      	ldr	r4, [pc, #688]	; (800107c <main+0x3cc>)
 8000dca:	61c2      	str	r2, [r0, #28]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000dcc:	0022      	movs	r2, r4
 8000dce:	321c      	adds	r2, #28
 8000dd0:	61e2      	str	r2, [r4, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000dd2:	6222      	str	r2, [r4, #32]
  ch.vtlist.delta = (systime_t)-1;
 8000dd4:	6261      	str	r1, [r4, #36]	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8000dd6:	4aaa      	ldr	r2, [pc, #680]	; (8001080 <main+0x3d0>)
 8000dd8:	49aa      	ldr	r1, [pc, #680]	; (8001084 <main+0x3d4>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000dda:	60a3      	str	r3, [r4, #8]
 8000ddc:	6011      	str	r1, [r2, #0]
  endmem  = __heap_end__;
 8000dde:	49aa      	ldr	r1, [pc, #680]	; (8001088 <main+0x3d8>)
 8000de0:	4aaa      	ldr	r2, [pc, #680]	; (800108c <main+0x3dc>)
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
 8000de2:	62a3      	str	r3, [r4, #40]	; 0x28
 8000de4:	6011      	str	r1, [r2, #0]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8000de6:	4aaa      	ldr	r2, [pc, #680]	; (8001090 <main+0x3e0>)
 8000de8:	49aa      	ldr	r1, [pc, #680]	; (8001094 <main+0x3e4>)
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8000dea:	6323      	str	r3, [r4, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8000dec:	6363      	str	r3, [r4, #52]	; 0x34
 8000dee:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
 8000df0:	6064      	str	r4, [r4, #4]
 8000df2:	6011      	str	r1, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000df4:	0011      	movs	r1, r2
 8000df6:	3110      	adds	r1, #16
 8000df8:	6111      	str	r1, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 8000dfa:	6151      	str	r1, [r2, #20]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000dfc:	2159      	movs	r1, #89	; 0x59
  H_NEXT(&default_heap.header) = NULL;
 8000dfe:	6093      	str	r3, [r2, #8]
  H_PAGES(&default_heap.header) = 0;
 8000e00:	60d3      	str	r3, [r2, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000e02:	6193      	str	r3, [r2, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000e04:	2280      	movs	r2, #128	; 0x80
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000e06:	5463      	strb	r3, [r4, r1]
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000e08:	66e3      	str	r3, [r4, #108]	; 0x6c
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000e0a:	6723      	str	r3, [r4, #112]	; 0x70
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000e0c:	335a      	adds	r3, #90	; 0x5a
 8000e0e:	54e5      	strb	r5, [r4, r3]
  tp->name      = name;
 8000e10:	4ba1      	ldr	r3, [pc, #644]	; (8001098 <main+0x3e8>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000e12:	6422      	str	r2, [r4, #64]	; 0x40
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000e14:	6523      	str	r3, [r4, #80]	; 0x50
  REG_INSERT(tp);
 8000e16:	0023      	movs	r3, r4
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000e18:	6762      	str	r2, [r4, #116]	; 0x74
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000e1a:	0022      	movs	r2, r4
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000e1c:	3338      	adds	r3, #56	; 0x38
 8000e1e:	6123      	str	r3, [r4, #16]
 8000e20:	6163      	str	r3, [r4, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8000e22:	61a3      	str	r3, [r4, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8000e24:	4b9d      	ldr	r3, [pc, #628]	; (800109c <main+0x3ec>)
 8000e26:	3260      	adds	r2, #96	; 0x60
 8000e28:	6622      	str	r2, [r4, #96]	; 0x60
 8000e2a:	6563      	str	r3, [r4, #84]	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000e2c:	0022      	movs	r2, r4
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000e2e:	2358      	movs	r3, #88	; 0x58
 8000e30:	3264      	adds	r2, #100	; 0x64
 8000e32:	54e5      	strb	r5, [r4, r3]
 8000e34:	6662      	str	r2, [r4, #100]	; 0x64
  tqp->prev = (thread_t *)tqp;
 8000e36:	66a2      	str	r2, [r4, #104]	; 0x68
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000e38:	4b99      	ldr	r3, [pc, #612]	; (80010a0 <main+0x3f0>)
 8000e3a:	6a02      	ldr	r2, [r0, #32]
 8000e3c:	64a4      	str	r4, [r4, #72]	; 0x48
 8000e3e:	4013      	ands	r3, r2
 8000e40:	64e4      	str	r4, [r4, #76]	; 0x4c
 8000e42:	6203      	str	r3, [r0, #32]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e44:	b662      	cpsie	i
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8000e46:	4d97      	ldr	r5, [pc, #604]	; (80010a4 <main+0x3f4>)
 8000e48:	0028      	movs	r0, r5
 8000e4a:	f7ff fd11 	bl	8000870 <chRegFindThreadByWorkingArea>
 8000e4e:	2800      	cmp	r0, #0
 8000e50:	d003      	beq.n	8000e5a <main+0x1aa>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e52:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000e54:	4b94      	ldr	r3, [pc, #592]	; (80010a8 <main+0x3f8>)
 8000e56:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000e58:	e7fe      	b.n	8000e58 <main+0x1a8>
 8000e5a:	0029      	movs	r1, r5
 8000e5c:	002b      	movs	r3, r5
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000e5e:	2255      	movs	r2, #85	; 0x55
 8000e60:	31d8      	adds	r1, #216	; 0xd8
 8000e62:	701a      	strb	r2, [r3, #0]
 8000e64:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000e66:	4299      	cmp	r1, r3
 8000e68:	d1fb      	bne.n	8000e62 <main+0x1b2>
 8000e6a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000e6c:	f7ff fca8 	bl	80007c0 <_dbg_check_lock>
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
 8000e70:	f7ff fa36 	bl	80002e0 <chDbgCheckClassI>
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000e74:	23ac      	movs	r3, #172	; 0xac
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000e76:	002a      	movs	r2, r5
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000e78:	50ed      	str	r5, [r5, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000e7a:	326c      	adds	r2, #108	; 0x6c
 8000e7c:	3b10      	subs	r3, #16
 8000e7e:	50ea      	str	r2, [r5, r3]
 8000e80:	4b8a      	ldr	r3, [pc, #552]	; (80010ac <main+0x3fc>)
 8000e82:	2280      	movs	r2, #128	; 0x80
 8000e84:	67eb      	str	r3, [r5, #124]	; 0x7c
 8000e86:	2300      	movs	r3, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000e88:	2198      	movs	r1, #152	; 0x98
  tp->state     = CH_STATE_WTSTART;
 8000e8a:	2002      	movs	r0, #2
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000e8c:	4e88      	ldr	r6, [pc, #544]	; (80010b0 <main+0x400>)
 8000e8e:	50ab      	str	r3, [r5, r2]
 8000e90:	320c      	adds	r2, #12
 8000e92:	50ae      	str	r6, [r5, r2]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000e94:	3a8b      	subs	r2, #139	; 0x8b
 8000e96:	506a      	str	r2, [r5, r1]
  tp->state     = CH_STATE_WTSTART;
 8000e98:	3118      	adds	r1, #24
 8000e9a:	5468      	strb	r0, [r5, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000e9c:	3101      	adds	r1, #1
 8000e9e:	546b      	strb	r3, [r5, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000ea0:	311b      	adds	r1, #27
 8000ea2:	506a      	str	r2, [r5, r1]
  tp->mtxlist   = NULL;
 8000ea4:	3904      	subs	r1, #4
 8000ea6:	506b      	str	r3, [r5, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000ea8:	3904      	subs	r1, #4
 8000eaa:	506b      	str	r3, [r5, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000eac:	33b2      	adds	r3, #178	; 0xb2
 8000eae:	54ea      	strb	r2, [r5, r3]
  tp->name      = name;
 8000eb0:	4a80      	ldr	r2, [pc, #512]	; (80010b4 <main+0x404>)
 8000eb2:	3b0a      	subs	r3, #10
 8000eb4:	50ea      	str	r2, [r5, r3]
  REG_INSERT(tp);
 8000eb6:	0028      	movs	r0, r5
 8000eb8:	22a4      	movs	r2, #164	; 0xa4
 8000eba:	3b08      	subs	r3, #8
 8000ebc:	50ec      	str	r4, [r5, r3]
 8000ebe:	6963      	ldr	r3, [r4, #20]
 8000ec0:	3090      	adds	r0, #144	; 0x90
 8000ec2:	50ab      	str	r3, [r5, r2]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000ec4:	002a      	movs	r2, r5
 8000ec6:	6118      	str	r0, [r3, #16]
 8000ec8:	23b8      	movs	r3, #184	; 0xb8
 8000eca:	32b8      	adds	r2, #184	; 0xb8
 8000ecc:	50ea      	str	r2, [r5, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000ece:	002b      	movs	r3, r5
 8000ed0:	22bc      	movs	r2, #188	; 0xbc
 8000ed2:	33bc      	adds	r3, #188	; 0xbc
 8000ed4:	50ab      	str	r3, [r5, r2]
  tqp->prev = (thread_t *)tqp;
 8000ed6:	3204      	adds	r2, #4
 8000ed8:	50ab      	str	r3, [r5, r2]
 8000eda:	6160      	str	r0, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 8000edc:	f7ff fae0 	bl	80004a0 <chSchWakeupS.constprop.11>
  chSysUnlock();
 8000ee0:	f7ff fc56 	bl	8000790 <chSysUnlock.lto_priv.14>
             (size >= THD_WORKING_AREA_SIZE(0)) &&
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8000ee4:	4d74      	ldr	r5, [pc, #464]	; (80010b8 <main+0x408>)
 8000ee6:	0028      	movs	r0, r5
 8000ee8:	f7ff fcc2 	bl	8000870 <chRegFindThreadByWorkingArea>
 8000eec:	2800      	cmp	r0, #0
 8000eee:	d003      	beq.n	8000ef8 <main+0x248>
 8000ef0:	b672      	cpsid	i
 8000ef2:	4b72      	ldr	r3, [pc, #456]	; (80010bc <main+0x40c>)
 8000ef4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000ef6:	e7fe      	b.n	8000ef6 <main+0x246>
 8000ef8:	0029      	movs	r1, r5
 8000efa:	002b      	movs	r3, r5
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000efc:	2255      	movs	r2, #85	; 0x55
 8000efe:	3149      	adds	r1, #73	; 0x49
 8000f00:	31ff      	adds	r1, #255	; 0xff
 8000f02:	701a      	strb	r2, [r3, #0]
 8000f04:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000f06:	428b      	cmp	r3, r1
 8000f08:	d1fb      	bne.n	8000f02 <main+0x252>
 8000f0a:	b672      	cpsid	i
 8000f0c:	f7ff fc58 	bl	80007c0 <_dbg_check_lock>
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000f10:	238e      	movs	r3, #142	; 0x8e
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f12:	002a      	movs	r2, r5
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000f14:	005b      	lsls	r3, r3, #1
 8000f16:	50ed      	str	r5, [r5, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f18:	32dc      	adds	r2, #220	; 0xdc
 8000f1a:	3b10      	subs	r3, #16
 8000f1c:	50ea      	str	r2, [r5, r3]
 8000f1e:	4a68      	ldr	r2, [pc, #416]	; (80010c0 <main+0x410>)
 8000f20:	3b20      	subs	r3, #32
 8000f22:	50ea      	str	r2, [r5, r3]
 8000f24:	2300      	movs	r3, #0
 8000f26:	22f0      	movs	r2, #240	; 0xf0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000f28:	2184      	movs	r1, #132	; 0x84
  tp->state     = CH_STATE_WTSTART;
 8000f2a:	2002      	movs	r0, #2
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f2c:	50ab      	str	r3, [r5, r2]
 8000f2e:	320c      	adds	r2, #12
 8000f30:	50ae      	str	r6, [r5, r2]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000f32:	0049      	lsls	r1, r1, #1
 8000f34:	3a7c      	subs	r2, #124	; 0x7c
 8000f36:	506a      	str	r2, [r5, r1]
  tp->state     = CH_STATE_WTSTART;
 8000f38:	3118      	adds	r1, #24
 8000f3a:	5468      	strb	r0, [r5, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000f3c:	2122      	movs	r1, #34	; 0x22
 8000f3e:	31ff      	adds	r1, #255	; 0xff
 8000f40:	546b      	strb	r3, [r5, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000f42:	311b      	adds	r1, #27
 8000f44:	506a      	str	r2, [r5, r1]
  tp->mtxlist   = NULL;
 8000f46:	32b8      	adds	r2, #184	; 0xb8
 8000f48:	50ab      	str	r3, [r5, r2]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000f4a:	3a04      	subs	r2, #4
 8000f4c:	50ab      	str	r3, [r5, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000f4e:	3a34      	subs	r2, #52	; 0x34
 8000f50:	3323      	adds	r3, #35	; 0x23
 8000f52:	3aff      	subs	r2, #255	; 0xff
 8000f54:	33ff      	adds	r3, #255	; 0xff
 8000f56:	54ea      	strb	r2, [r5, r3]
  tp->name      = name;
 8000f58:	4a5a      	ldr	r2, [pc, #360]	; (80010c4 <main+0x414>)
 8000f5a:	3b0a      	subs	r3, #10
 8000f5c:	50ea      	str	r2, [r5, r3]
  REG_INSERT(tp);
 8000f5e:	228a      	movs	r2, #138	; 0x8a
 8000f60:	3b08      	subs	r3, #8
 8000f62:	50ec      	str	r4, [r5, r3]
 8000f64:	6963      	ldr	r3, [r4, #20]
 8000f66:	0052      	lsls	r2, r2, #1
 8000f68:	1c68      	adds	r0, r5, #1
 8000f6a:	50ab      	str	r3, [r5, r2]
 8000f6c:	30ff      	adds	r0, #255	; 0xff
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000f6e:	002a      	movs	r2, r5
 8000f70:	6118      	str	r0, [r3, #16]
 8000f72:	2394      	movs	r3, #148	; 0x94
 8000f74:	3229      	adds	r2, #41	; 0x29
 8000f76:	32ff      	adds	r2, #255	; 0xff
 8000f78:	005b      	lsls	r3, r3, #1
 8000f7a:	50ea      	str	r2, [r5, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000f7c:	002b      	movs	r3, r5
 8000f7e:	2296      	movs	r2, #150	; 0x96
 8000f80:	332d      	adds	r3, #45	; 0x2d
 8000f82:	33ff      	adds	r3, #255	; 0xff
 8000f84:	0052      	lsls	r2, r2, #1
 8000f86:	50ab      	str	r3, [r5, r2]
  tqp->prev = (thread_t *)tqp;
 8000f88:	3204      	adds	r2, #4
 8000f8a:	50ab      	str	r3, [r5, r2]
 8000f8c:	6160      	str	r0, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000f8e:	f7ff fa87 	bl	80004a0 <chSchWakeupS.constprop.11>
  chSysUnlock();
 8000f92:	f7ff fbfd 	bl	8000790 <chSysUnlock.lto_priv.14>
 8000f96:	4b4c      	ldr	r3, [pc, #304]	; (80010c8 <main+0x418>)
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
 8000f98:	2601      	movs	r6, #1
 8000f9a:	4698      	mov	r8, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000f9c:	4f4b      	ldr	r7, [pc, #300]	; (80010cc <main+0x41c>)
 8000f9e:	ad01      	add	r5, sp, #4
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
 8000fa0:	4276      	negs	r6, r6
 8000fa2:	b672      	cpsid	i
 8000fa4:	f7ff fc0c 	bl	80007c0 <_dbg_check_lock>
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {

  chDbgCheckClassS();
 8000fa8:	f7ff f98a 	bl	80002c0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000fac:	69a3      	ldr	r3, [r4, #24]
 8000fae:	4699      	mov	r9, r3
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8000fb0:	f7ff f996 	bl	80002e0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8000fb4:	464b      	mov	r3, r9
 8000fb6:	612b      	str	r3, [r5, #16]
  vtp->func = vtfunc;
 8000fb8:	4643      	mov	r3, r8
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000fba:	22fa      	movs	r2, #250	; 0xfa

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8000fbc:	60eb      	str	r3, [r5, #12]
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
 8000fbe:	69e3      	ldr	r3, [r4, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000fc0:	0092      	lsls	r2, r2, #2
 8000fc2:	6899      	ldr	r1, [r3, #8]
 8000fc4:	42b9      	cmp	r1, r7
 8000fc6:	d804      	bhi.n	8000fd2 <main+0x322>
    delta -= p->delta;
    p = p->next;
 8000fc8:	681b      	ldr	r3, [r3, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8000fca:	1a52      	subs	r2, r2, r1
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000fcc:	6899      	ldr	r1, [r3, #8]
 8000fce:	4291      	cmp	r1, r2
 8000fd0:	d3fa      	bcc.n	8000fc8 <main+0x318>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000fd2:	6859      	ldr	r1, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8000fd4:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
 8000fd6:	6069      	str	r1, [r5, #4]
  vtp->prev->next = vtp;
 8000fd8:	600d      	str	r5, [r1, #0]
  p->prev = vtp;
 8000fda:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
 8000fdc:	60aa      	str	r2, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8000fde:	6899      	ldr	r1, [r3, #8]
    chSchGoSleepS(newstate);
 8000fe0:	2008      	movs	r0, #8
 8000fe2:	1a8a      	subs	r2, r1, r2
 8000fe4:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000fe6:	6266      	str	r6, [r4, #36]	; 0x24
 8000fe8:	f7ff fa92 	bl	8000510 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8000fec:	f7ff f978 	bl	80002e0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8000ff0:	9b04      	ldr	r3, [sp, #16]
 8000ff2:	2b00      	cmp	r3, #0
 8000ff4:	d00c      	beq.n	8001010 <main+0x360>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8000ff6:	f7ff f973 	bl	80002e0 <chDbgCheckClassI>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
 8000ffa:	68a9      	ldr	r1, [r5, #8]
 8000ffc:	682b      	ldr	r3, [r5, #0]
 8000ffe:	468c      	mov	ip, r1
 8001000:	689a      	ldr	r2, [r3, #8]
 8001002:	4462      	add	r2, ip
 8001004:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
 8001006:	686a      	ldr	r2, [r5, #4]
 8001008:	6013      	str	r3, [r2, #0]
  vtp->next->prev = vtp->prev;
 800100a:	682b      	ldr	r3, [r5, #0]
 800100c:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
 800100e:	6266      	str	r6, [r4, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001010:	f7ff fba6 	bl	8000760 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001014:	6823      	ldr	r3, [r4, #0]
 8001016:	42a3      	cmp	r3, r4
 8001018:	d004      	beq.n	8001024 <main+0x374>
 800101a:	69a2      	ldr	r2, [r4, #24]
 800101c:	689b      	ldr	r3, [r3, #8]
 800101e:	6892      	ldr	r2, [r2, #8]
 8001020:	429a      	cmp	r2, r3
 8001022:	d301      	bcc.n	8001028 <main+0x378>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001024:	b662      	cpsie	i
 8001026:	e7bc      	b.n	8000fa2 <main+0x2f2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001028:	b672      	cpsid	i
 800102a:	4b29      	ldr	r3, [pc, #164]	; (80010d0 <main+0x420>)
 800102c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800102e:	e7fe      	b.n	800102e <main+0x37e>
 8001030:	40021000 	.word	0x40021000
 8001034:	ffbfffff 	.word	0xffbfffff
 8001038:	40007000 	.word	0x40007000
 800103c:	65550000 	.word	0x65550000
 8001040:	0000ff30 	.word	0x0000ff30
 8001044:	11002222 	.word	0x11002222
 8001048:	2a80a0aa 	.word	0x2a80a0aa
 800104c:	48000400 	.word	0x48000400
 8001050:	55545555 	.word	0x55545555
 8001054:	0000ffff 	.word	0x0000ffff
 8001058:	48000800 	.word	0x48000800
 800105c:	55555555 	.word	0x55555555
 8001060:	48001400 	.word	0x48001400
 8001064:	2000049c 	.word	0x2000049c
 8001068:	200004b8 	.word	0x200004b8
 800106c:	40000400 	.word	0x40000400
 8001070:	e000e010 	.word	0xe000e010
 8001074:	0000bb7f 	.word	0x0000bb7f
 8001078:	e000ed00 	.word	0xe000ed00
 800107c:	20000420 	.word	0x20000420
 8001080:	20000620 	.word	0x20000620
 8001084:	20000700 	.word	0x20000700
 8001088:	20001800 	.word	0x20001800
 800108c:	200004d4 	.word	0x200004d4
 8001090:	20000400 	.word	0x20000400
 8001094:	080007f1 	.word	0x080007f1
 8001098:	080012fc 	.word	0x080012fc
 800109c:	20000200 	.word	0x20000200
 80010a0:	ff00ffff 	.word	0xff00ffff
 80010a4:	20000628 	.word	0x20000628
 80010a8:	08001240 	.word	0x08001240
 80010ac:	08000481 	.word	0x08000481
 80010b0:	080001b1 	.word	0x080001b1
 80010b4:	080013d0 	.word	0x080013d0
 80010b8:	200004d8 	.word	0x200004d8
 80010bc:	08001364 	.word	0x08001364
 80010c0:	080001e1 	.word	0x080001e1
 80010c4:	080013d8 	.word	0x080013d8
 80010c8:	08000421 	.word	0x08000421
 80010cc:	000003e7 	.word	0x000003e7
 80010d0:	08001358 	.word	0x08001358
	...

080010e0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80010e0:	b570      	push	{r4, r5, r6, lr}
 80010e2:	0006      	movs	r6, r0
 80010e4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80010e6:	f7ff fb6b 	bl	80007c0 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80010ea:	4d11      	ldr	r5, [pc, #68]	; (8001130 <chThdExit+0x50>)
 80010ec:	69ac      	ldr	r4, [r5, #24]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80010ee:	6266      	str	r6, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80010f0:	0026      	movs	r6, r4
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80010f2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80010f4:	3628      	adds	r6, #40	; 0x28
 80010f6:	4286      	cmp	r6, r0
 80010f8:	d006      	beq.n	8001108 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80010fa:	6803      	ldr	r3, [r0, #0]
 80010fc:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 80010fe:	f7ff f8ff 	bl	8000300 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8001102:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001104:	42b0      	cmp	r0, r6
 8001106:	d1f8      	bne.n	80010fa <chThdExit+0x1a>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8001108:	2322      	movs	r3, #34	; 0x22
 800110a:	5ce3      	ldrb	r3, [r4, r3]
 800110c:	2b00      	cmp	r3, #0
 800110e:	d108      	bne.n	8001122 <chThdExit+0x42>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8001110:	2321      	movs	r3, #33	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8001112:	5ce3      	ldrb	r3, [r4, r3]
 8001114:	079b      	lsls	r3, r3, #30
 8001116:	d104      	bne.n	8001122 <chThdExit+0x42>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8001118:	6922      	ldr	r2, [r4, #16]
 800111a:	6963      	ldr	r3, [r4, #20]
 800111c:	611a      	str	r2, [r3, #16]
 800111e:	6922      	ldr	r2, [r4, #16]
 8001120:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001122:	200f      	movs	r0, #15
 8001124:	f7ff f9f4 	bl	8000510 <chSchGoSleepS>
 8001128:	b672      	cpsid	i
 800112a:	4b02      	ldr	r3, [pc, #8]	; (8001134 <chThdExit+0x54>)
 800112c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800112e:	e7fe      	b.n	800112e <chThdExit+0x4e>
 8001130:	20000420 	.word	0x20000420
 8001134:	0800124c 	.word	0x0800124c
	...

08001140 <__init_ram_areas>:
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001140:	2280      	movs	r2, #128	; 0x80
 8001142:	4694      	mov	ip, r2
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001144:	b5f0      	push	{r4, r5, r6, r7, lr}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001146:	2600      	movs	r6, #0
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001148:	4f10      	ldr	r7, [pc, #64]	; (800118c <__init_ram_areas+0x4c>)
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800114a:	4d11      	ldr	r5, [pc, #68]	; (8001190 <__init_ram_areas+0x50>)
 800114c:	4c11      	ldr	r4, [pc, #68]	; (8001194 <__init_ram_areas+0x54>)
 800114e:	4b12      	ldr	r3, [pc, #72]	; (8001198 <__init_ram_areas+0x58>)
 8001150:	4912      	ldr	r1, [pc, #72]	; (800119c <__init_ram_areas+0x5c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001152:	44bc      	add	ip, r7
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001154:	429c      	cmp	r4, r3
 8001156:	d90d      	bls.n	8001174 <__init_ram_areas+0x34>
 8001158:	001a      	movs	r2, r3
      *p = *tp;
 800115a:	c901      	ldmia	r1!, {r0}
 800115c:	c201      	stmia	r2!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800115e:	4294      	cmp	r4, r2
 8001160:	d8fb      	bhi.n	800115a <__init_ram_areas+0x1a>
 8001162:	43da      	mvns	r2, r3
 8001164:	1914      	adds	r4, r2, r4
 8001166:	08a4      	lsrs	r4, r4, #2
 8001168:	3401      	adds	r4, #1
 800116a:	00a4      	lsls	r4, r4, #2
 800116c:	191b      	adds	r3, r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800116e:	429d      	cmp	r5, r3
 8001170:	d902      	bls.n	8001178 <__init_ram_areas+0x38>
      *p = 0;
 8001172:	c340      	stmia	r3!, {r6}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001174:	429d      	cmp	r5, r3
 8001176:	d8fc      	bhi.n	8001172 <__init_ram_areas+0x32>
      *p = 0;
      p++;
    }
    rap++;
 8001178:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800117a:	4567      	cmp	r7, ip
 800117c:	d004      	beq.n	8001188 <__init_ram_areas+0x48>
 800117e:	68bc      	ldr	r4, [r7, #8]
 8001180:	68fd      	ldr	r5, [r7, #12]
 8001182:	6839      	ldr	r1, [r7, #0]
 8001184:	687b      	ldr	r3, [r7, #4]
 8001186:	e7e5      	b.n	8001154 <__init_ram_areas+0x14>
#endif
}
 8001188:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800118a:	46c0      	nop			; (mov r8, r8)
 800118c:	08001270 	.word	0x08001270
 8001190:	20000700 	.word	0x20000700
 8001194:	20000700 	.word	0x20000700
 8001198:	20000700 	.word	0x20000700
 800119c:	080013e0 	.word	0x080013e0

080011a0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80011a0:	e7fe      	b.n	80011a0 <__default_exit>
 80011a2:	46c0      	nop			; (mov r8, r8)
	...

080011b0 <__late_init>:
 80011b0:	4770      	bx	lr
 80011b2:	46c0      	nop			; (mov r8, r8)
	...

080011c0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80011c0:	4770      	bx	lr
 80011c2:	46c0      	nop			; (mov r8, r8)
