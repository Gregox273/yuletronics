
build/yuletronics.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
 80000c4:	f380 8808 	msr	MSP, r0
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
 80000ca:	f380 8809 	msr	PSP, r0
 80000ce:	2002      	movs	r0, #2
 80000d0:	f380 8814 	msr	CONTROL, r0
 80000d4:	f3bf 8f6f 	isb	sy
 80000d8:	f000 ffaa 	bl	8001030 <__core_init>
 80000dc:	f000 fa30 	bl	8000540 <__early_init>
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
 80000e6:	4291      	cmp	r1, r2
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
 80000ea:	6008      	str	r0, [r1, #0]
 80000ec:	3104      	adds	r1, #4
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
 80000f4:	4291      	cmp	r1, r2
 80000f6:	da02      	bge.n	80000fe <endpsloop>
 80000f8:	6008      	str	r0, [r1, #0]
 80000fa:	3104      	adds	r1, #4
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
 8000104:	429a      	cmp	r2, r3
 8000106:	da04      	bge.n	8000112 <enddloop>
 8000108:	6808      	ldr	r0, [r1, #0]
 800010a:	6010      	str	r0, [r2, #0]
 800010c:	3104      	adds	r1, #4
 800010e:	3204      	adds	r2, #4
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
 8000112:	2000      	movs	r0, #0
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
 8000118:	4291      	cmp	r1, r2
 800011a:	da02      	bge.n	8000122 <endbloop>
 800011c:	6008      	str	r0, [r1, #0]
 800011e:	3104      	adds	r1, #4
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
 8000122:	f000 ff45 	bl	8000fb0 <__init_ram_areas>
 8000126:	f000 ff7b 	bl	8001020 <__late_init>
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
 800012e:	42ac      	cmp	r4, r5
 8000130:	da03      	bge.n	800013a <endinitloop>
 8000132:	6821      	ldr	r1, [r4, #0]
 8000134:	4788      	blx	r1
 8000136:	3404      	adds	r4, #4
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
 800013a:	f000 fd49 	bl	8000bd0 <main>
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
 8000142:	42ac      	cmp	r4, r5
 8000144:	da03      	bge.n	800014e <endfiniloop>
 8000146:	6821      	ldr	r1, [r4, #0]
 8000148:	4788      	blx	r1
 800014a:	3404      	adds	r4, #4
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000400 	.word	0x20000400
 800015c:	55555555 	.word	0x55555555
 8000160:	20000000 	.word	0x20000000
 8000164:	20000200 	.word	0x20000200
 8000168:	08001248 	.word	0x08001248
 800016c:	20000400 	.word	0x20000400
 8000170:	20000400 	.word	0x20000400
 8000174:	20000400 	.word	0x20000400
 8000178:	200006cc 	.word	0x200006cc
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	080000c0 	.word	0x080000c0
 8000188:	080000c0 	.word	0x080000c0
 800018c:	08001011 	.word	0x08001011

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	f000 fa66 	bl	8000680 <_dbg_check_unlock>
 80001b4:	b662      	cpsie	i
 80001b6:	1c28      	adds	r0, r5, #0
 80001b8:	47a0      	blx	r4
 80001ba:	2000      	movs	r0, #0
 80001bc:	f000 fec8 	bl	8000f50 <chThdExit>

080001c0 <_port_switch_from_isr>:
 80001c0:	f000 fa8e 	bl	80006e0 <_dbg_check_lock>
 80001c4:	f000 fa14 	bl	80005f0 <chSchDoReschedule>
 80001c8:	f000 fa5a 	bl	8000680 <_dbg_check_unlock>

080001cc <_port_exit_from_isr>:
 80001cc:	4a01      	ldr	r2, [pc, #4]	; (80001d4 <_port_exit_from_isr+0x8>)
 80001ce:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <_port_exit_from_isr+0xc>)
 80001d0:	6013      	str	r3, [r2, #0]
 80001d2:	e7fe      	b.n	80001d2 <_port_exit_from_isr+0x6>
 80001d4:	e000ed04 	.word	0xe000ed04
 80001d8:	80000000 	.word	0x80000000
 80001dc:	00000000 	.word	0x00000000

080001e0 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80001e0:	4b02      	ldr	r3, [pc, #8]	; (80001ec <Thread1+0xc>)
 80001e2:	4a03      	ldr	r2, [pc, #12]	; (80001f0 <Thread1+0x10>)
 80001e4:	699b      	ldr	r3, [r3, #24]
 80001e6:	619a      	str	r2, [r3, #24]
 80001e8:	e7fe      	b.n	80001e8 <Thread1+0x8>
 80001ea:	46c0      	nop			; (mov r8, r8)
 80001ec:	20000420 	.word	0x20000420
 80001f0:	0800112c 	.word	0x0800112c
	...

08000200 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000200:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000204:	3320      	adds	r3, #32
 8000206:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800020a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800020c:	4770      	bx	lr
 800020e:	46c0      	nop			; (mov r8, r8)

08000210 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000210:	4b05      	ldr	r3, [pc, #20]	; (8000228 <chDbgCheckClassS+0x18>)
 8000212:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000214:	2a00      	cmp	r2, #0
 8000216:	d103      	bne.n	8000220 <chDbgCheckClassS+0x10>
 8000218:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800021a:	2a00      	cmp	r2, #0
 800021c:	dd00      	ble.n	8000220 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 800021e:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000220:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000222:	4a02      	ldr	r2, [pc, #8]	; (800022c <chDbgCheckClassS+0x1c>)
 8000224:	62da      	str	r2, [r3, #44]	; 0x2c
 8000226:	e7fe      	b.n	8000226 <chDbgCheckClassS+0x16>
 8000228:	20000420 	.word	0x20000420
 800022c:	08001134 	.word	0x08001134

08000230 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000230:	4b05      	ldr	r3, [pc, #20]	; (8000248 <chDbgCheckClassI+0x18>)
 8000232:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000234:	2a00      	cmp	r2, #0
 8000236:	db03      	blt.n	8000240 <chDbgCheckClassI+0x10>
 8000238:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800023a:	2a00      	cmp	r2, #0
 800023c:	dd00      	ble.n	8000240 <chDbgCheckClassI+0x10>
    chSysHalt("SV#10");
  }
}
 800023e:	4770      	bx	lr
 8000240:	b672      	cpsid	i
 8000242:	4a02      	ldr	r2, [pc, #8]	; (800024c <chDbgCheckClassI+0x1c>)
 8000244:	62da      	str	r2, [r3, #44]	; 0x2c
 8000246:	e7fe      	b.n	8000246 <chDbgCheckClassI+0x16>
 8000248:	20000420 	.word	0x20000420
 800024c:	0800113c 	.word	0x0800113c

08000250 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000250:	b510      	push	{r4, lr}
 8000252:	0004      	movs	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 8000254:	f7ff ffec 	bl	8000230 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000258:	2c00      	cmp	r4, #0
 800025a:	d019      	beq.n	8000290 <chSchReadyI+0x40>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800025c:	2320      	movs	r3, #32
 800025e:	5ce2      	ldrb	r2, [r4, r3]
 8000260:	2a00      	cmp	r2, #0
 8000262:	d010      	beq.n	8000286 <chSchReadyI+0x36>
 8000264:	2a0f      	cmp	r2, #15
 8000266:	d00e      	beq.n	8000286 <chSchReadyI+0x36>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000268:	2200      	movs	r2, #0
 800026a:	54e2      	strb	r2, [r4, r3]
 800026c:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 800026e:	4b0b      	ldr	r3, [pc, #44]	; (800029c <chSchReadyI+0x4c>)
  do {
    cp = cp->queue.next;
 8000270:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000272:	6899      	ldr	r1, [r3, #8]
 8000274:	4291      	cmp	r1, r2
 8000276:	d2fb      	bcs.n	8000270 <chSchReadyI+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000278:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800027a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 800027c:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800027e:	0020      	movs	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8000280:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000282:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000284:	bd10      	pop	{r4, pc}
 8000286:	b672      	cpsid	i
 8000288:	4a05      	ldr	r2, [pc, #20]	; (80002a0 <chSchReadyI+0x50>)
 800028a:	4b04      	ldr	r3, [pc, #16]	; (800029c <chSchReadyI+0x4c>)
 800028c:	62da      	str	r2, [r3, #44]	; 0x2c
 800028e:	e7fe      	b.n	800028e <chSchReadyI+0x3e>
 8000290:	b672      	cpsid	i
 8000292:	4a03      	ldr	r2, [pc, #12]	; (80002a0 <chSchReadyI+0x50>)
 8000294:	4b01      	ldr	r3, [pc, #4]	; (800029c <chSchReadyI+0x4c>)
 8000296:	62da      	str	r2, [r3, #44]	; 0x2c
 8000298:	e7fe      	b.n	8000298 <chSchReadyI+0x48>
 800029a:	46c0      	nop			; (mov r8, r8)
 800029c:	20000420 	.word	0x20000420
 80002a0:	08001194 	.word	0x08001194
	...

080002b0 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80002b0:	4b06      	ldr	r3, [pc, #24]	; (80002cc <_dbg_check_unlock_from_isr+0x1c>)
 80002b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80002b4:	2a00      	cmp	r2, #0
 80002b6:	dd05      	ble.n	80002c4 <_dbg_check_unlock_from_isr+0x14>
 80002b8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80002ba:	2a00      	cmp	r2, #0
 80002bc:	dd02      	ble.n	80002c4 <_dbg_check_unlock_from_isr+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 80002be:	2200      	movs	r2, #0
 80002c0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80002c2:	4770      	bx	lr
 80002c4:	b672      	cpsid	i
 80002c6:	4a02      	ldr	r2, [pc, #8]	; (80002d0 <_dbg_check_unlock_from_isr+0x20>)
 80002c8:	62da      	str	r2, [r3, #44]	; 0x2c
 80002ca:	e7fe      	b.n	80002ca <_dbg_check_unlock_from_isr+0x1a>
 80002cc:	20000420 	.word	0x20000420
 80002d0:	08001144 	.word	0x08001144
	...

080002e0 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80002e0:	4b06      	ldr	r3, [pc, #24]	; (80002fc <_dbg_check_lock_from_isr+0x1c>)
 80002e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80002e4:	2a00      	cmp	r2, #0
 80002e6:	dd02      	ble.n	80002ee <_dbg_check_lock_from_isr+0xe>
 80002e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80002ea:	2a00      	cmp	r2, #0
 80002ec:	d003      	beq.n	80002f6 <_dbg_check_lock_from_isr+0x16>
 80002ee:	b672      	cpsid	i
 80002f0:	4a03      	ldr	r2, [pc, #12]	; (8000300 <_dbg_check_lock_from_isr+0x20>)
 80002f2:	62da      	str	r2, [r3, #44]	; 0x2c
 80002f4:	e7fe      	b.n	80002f4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80002f6:	2201      	movs	r2, #1
 80002f8:	635a      	str	r2, [r3, #52]	; 0x34
}
 80002fa:	4770      	bx	lr
 80002fc:	20000420 	.word	0x20000420
 8000300:	0800114c 	.word	0x0800114c
	...

08000310 <_idle_thread>:
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8000310:	bf30      	wfi
 8000312:	e7fd      	b.n	8000310 <_idle_thread>
	...

08000320 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000320:	e7fe      	b.n	8000320 <BusFault_Handler>
 8000322:	46c0      	nop			; (mov r8, r8)
	...

08000330 <chSchWakeupS.constprop.7>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000330:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8000332:	4d17      	ldr	r5, [pc, #92]	; (8000390 <chSchWakeupS.constprop.7+0x60>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000334:	0004      	movs	r4, r0
  thread_t *otp = currp;
 8000336:	69ae      	ldr	r6, [r5, #24]

  chDbgCheckClassS();
 8000338:	f7ff ff6a 	bl	8000210 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800033c:	682a      	ldr	r2, [r5, #0]
 800033e:	68b3      	ldr	r3, [r6, #8]
 8000340:	42aa      	cmp	r2, r5
 8000342:	d002      	beq.n	800034a <chSchWakeupS.constprop.7+0x1a>
 8000344:	6892      	ldr	r2, [r2, #8]
 8000346:	4293      	cmp	r3, r2
 8000348:	d31e      	bcc.n	8000388 <chSchWakeupS.constprop.7+0x58>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800034a:	2200      	movs	r2, #0
 800034c:	6262      	str	r2, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800034e:	68a2      	ldr	r2, [r4, #8]
 8000350:	429a      	cmp	r2, r3
 8000352:	d915      	bls.n	8000380 <chSchWakeupS.constprop.7+0x50>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 8000354:	0030      	movs	r0, r6
 8000356:	f7ff ff7b 	bl	8000250 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 800035a:	2201      	movs	r2, #1
 800035c:	2320      	movs	r3, #32
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 800035e:	0001      	movs	r1, r0
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8000360:	61ac      	str	r4, [r5, #24]
    ntp->state = CH_STATE_CURRENT;
 8000362:	54e2      	strb	r2, [r4, r3]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000364:	f3ef 8309 	mrs	r3, PSP

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000368:	69c2      	ldr	r2, [r0, #28]
 800036a:	3b24      	subs	r3, #36	; 0x24
 800036c:	429a      	cmp	r2, r3
 800036e:	d803      	bhi.n	8000378 <chSchWakeupS.constprop.7+0x48>
 8000370:	0020      	movs	r0, r4
 8000372:	f7ff ff0d 	bl	8000190 <_port_switch>
  }
}
 8000376:	bd70      	pop	{r4, r5, r6, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000378:	b672      	cpsid	i
 800037a:	4b06      	ldr	r3, [pc, #24]	; (8000394 <chSchWakeupS.constprop.7+0x64>)
 800037c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800037e:	e7fe      	b.n	800037e <chSchWakeupS.constprop.7+0x4e>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 8000380:	0020      	movs	r0, r4
 8000382:	f7ff ff65 	bl	8000250 <chSchReadyI>
 8000386:	e7f6      	b.n	8000376 <chSchWakeupS.constprop.7+0x46>
 8000388:	b672      	cpsid	i
 800038a:	4b03      	ldr	r3, [pc, #12]	; (8000398 <chSchWakeupS.constprop.7+0x68>)
 800038c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800038e:	e7fe      	b.n	800038e <chSchWakeupS.constprop.7+0x5e>
 8000390:	20000420 	.word	0x20000420
 8000394:	08001154 	.word	0x08001154
 8000398:	0800121c 	.word	0x0800121c
 800039c:	00000000 	.word	0x00000000

080003a0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80003a0:	b570      	push	{r4, r5, r6, lr}
 80003a2:	0006      	movs	r6, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 80003a4:	f7ff ff34 	bl	8000210 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 80003a8:	2320      	movs	r3, #32
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80003aa:	4c0c      	ldr	r4, [pc, #48]	; (80003dc <chSchGoSleepS+0x3c>)
 80003ac:	69a5      	ldr	r5, [r4, #24]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80003ae:	6820      	ldr	r0, [r4, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80003b0:	54ee      	strb	r6, [r5, r3]

  tqp->next             = tp->queue.next;
 80003b2:	6802      	ldr	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80003b4:	6054      	str	r4, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80003b6:	6022      	str	r2, [r4, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80003b8:	2201      	movs	r2, #1
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80003ba:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 80003bc:	54c2      	strb	r2, [r0, r3]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80003be:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80003c2:	69ea      	ldr	r2, [r5, #28]
 80003c4:	3b24      	subs	r3, #36	; 0x24
 80003c6:	429a      	cmp	r2, r3
 80003c8:	d803      	bhi.n	80003d2 <chSchGoSleepS+0x32>
 80003ca:	0029      	movs	r1, r5
 80003cc:	f7ff fee0 	bl	8000190 <_port_switch>
}
 80003d0:	bd70      	pop	{r4, r5, r6, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003d2:	b672      	cpsid	i
 80003d4:	4b02      	ldr	r3, [pc, #8]	; (80003e0 <chSchGoSleepS+0x40>)
 80003d6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80003d8:	e7fe      	b.n	80003d8 <chSchGoSleepS+0x38>
 80003da:	46c0      	nop			; (mov r8, r8)
 80003dc:	20000420 	.word	0x20000420
 80003e0:	08001154 	.word	0x08001154
	...

080003f0 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80003f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80003f2:	4657      	mov	r7, sl
 80003f4:	464e      	mov	r6, r9
 80003f6:	4645      	mov	r5, r8
 80003f8:	b4e0      	push	{r5, r6, r7}

  OSAL_IRQ_PROLOGUE();
 80003fa:	4677      	mov	r7, lr
 80003fc:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80003fe:	4c47      	ldr	r4, [pc, #284]	; (800051c <Vector7C+0x12c>)
 8000400:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000402:	2b00      	cmp	r3, #0
 8000404:	db02      	blt.n	800040c <Vector7C+0x1c>
 8000406:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8000408:	2a00      	cmp	r2, #0
 800040a:	d003      	beq.n	8000414 <Vector7C+0x24>
 800040c:	b672      	cpsid	i
 800040e:	4b44      	ldr	r3, [pc, #272]	; (8000520 <Vector7C+0x130>)
 8000410:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000412:	e7fe      	b.n	8000412 <Vector7C+0x22>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 8000414:	3301      	adds	r3, #1
 8000416:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000418:	b662      	cpsie	i

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800041a:	2680      	movs	r6, #128	; 0x80
 800041c:	05f6      	lsls	r6, r6, #23
 800041e:	6933      	ldr	r3, [r6, #16]
 8000420:	079b      	lsls	r3, r3, #30
 8000422:	d40a      	bmi.n	800043a <Vector7C+0x4a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000424:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000426:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000428:	2b00      	cmp	r3, #0
 800042a:	dd02      	ble.n	8000432 <Vector7C+0x42>
 800042c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800042e:	2a00      	cmp	r2, #0
 8000430:	d035      	beq.n	800049e <Vector7C+0xae>
 8000432:	b672      	cpsid	i
 8000434:	4b3b      	ldr	r3, [pc, #236]	; (8000524 <Vector7C+0x134>)
 8000436:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000438:	e7fe      	b.n	8000438 <Vector7C+0x48>
    STM32_ST_TIM->SR = 0U;
 800043a:	6132      	str	r2, [r6, #16]
 800043c:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800043e:	f7ff ff4f 	bl	80002e0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 8000442:	f7ff fef5 	bl	8000230 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 8000446:	f7ff fef3 	bl	8000230 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 800044a:	69e5      	ldr	r5, [r4, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800044c:	6a72      	ldr	r2, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800044e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000450:	68ab      	ldr	r3, [r5, #8]
 8000452:	1a50      	subs	r0, r2, r1
 8000454:	4298      	cmp	r0, r3
 8000456:	d340      	bcc.n	80004da <Vector7C+0xea>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000458:	221c      	movs	r2, #28
 800045a:	4691      	mov	r9, r2
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 800045c:	2200      	movs	r2, #0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800045e:	44a1      	add	r9, r4
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000460:	4690      	mov	r8, r2
 8000462:	e00e      	b.n	8000482 <Vector7C+0x92>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000464:	f7ff ff24 	bl	80002b0 <_dbg_check_unlock_from_isr>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000468:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800046a:	6928      	ldr	r0, [r5, #16]
 800046c:	47d0      	blx	sl
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800046e:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000470:	f7ff ff36 	bl	80002e0 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8000474:	69e5      	ldr	r5, [r4, #28]
 8000476:	6a72      	ldr	r2, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000478:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800047a:	68ab      	ldr	r3, [r5, #8]
 800047c:	1a50      	subs	r0, r2, r1
 800047e:	4283      	cmp	r3, r0
 8000480:	d82b      	bhi.n	80004da <Vector7C+0xea>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000482:	464a      	mov	r2, r9
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000484:	18cb      	adds	r3, r1, r3
 8000486:	62a3      	str	r3, [r4, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000488:	682b      	ldr	r3, [r5, #0]
 800048a:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 800048c:	68ea      	ldr	r2, [r5, #12]

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
 800048e:	61e3      	str	r3, [r4, #28]
    fn = vtp->func;
 8000490:	4692      	mov	sl, r2
    vtp->func = NULL;
 8000492:	4642      	mov	r2, r8
 8000494:	60ea      	str	r2, [r5, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000496:	454b      	cmp	r3, r9
 8000498:	d1e4      	bne.n	8000464 <Vector7C+0x74>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800049a:	60f2      	str	r2, [r6, #12]
 800049c:	e7e2      	b.n	8000464 <Vector7C+0x74>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 800049e:	3b01      	subs	r3, #1
 80004a0:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80004a2:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80004a4:	370f      	adds	r7, #15
 80004a6:	d010      	beq.n	80004ca <Vector7C+0xda>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004a8:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80004aa:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80004ae:	3b20      	subs	r3, #32
 80004b0:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80004b4:	2280      	movs	r2, #128	; 0x80
 80004b6:	0452      	lsls	r2, r2, #17
 80004b8:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80004ba:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80004bc:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80004be:	6889      	ldr	r1, [r1, #8]
 80004c0:	6892      	ldr	r2, [r2, #8]
 80004c2:	4291      	cmp	r1, r2
 80004c4:	d806      	bhi.n	80004d4 <Vector7C+0xe4>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80004c6:	4a18      	ldr	r2, [pc, #96]	; (8000528 <Vector7C+0x138>)
 80004c8:	619a      	str	r2, [r3, #24]
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 80004ca:	bc1c      	pop	{r2, r3, r4}
 80004cc:	4690      	mov	r8, r2
 80004ce:	4699      	mov	r9, r3
 80004d0:	46a2      	mov	sl, r4
 80004d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80004d4:	4a15      	ldr	r2, [pc, #84]	; (800052c <Vector7C+0x13c>)
 80004d6:	619a      	str	r2, [r3, #24]
 80004d8:	e7f7      	b.n	80004ca <Vector7C+0xda>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80004da:	0020      	movs	r0, r4
 80004dc:	301c      	adds	r0, #28
 80004de:	4285      	cmp	r5, r0
 80004e0:	d018      	beq.n	8000514 <Vector7C+0x124>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 80004e2:	185b      	adds	r3, r3, r1
 80004e4:	1a9b      	subs	r3, r3, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80004e6:	2b01      	cmp	r3, #1
 80004e8:	d800      	bhi.n	80004ec <Vector7C+0xfc>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80004ea:	2302      	movs	r3, #2
  }
  port_timer_set_alarm(now + delta);
 80004ec:	189a      	adds	r2, r3, r2
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80004ee:	2380      	movs	r3, #128	; 0x80
 80004f0:	05db      	lsls	r3, r3, #23
 80004f2:	68d8      	ldr	r0, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80004f4:	0780      	lsls	r0, r0, #30
 80004f6:	d509      	bpl.n	800050c <Vector7C+0x11c>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80004f8:	635a      	str	r2, [r3, #52]	; 0x34
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80004fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 80004fc:	1a52      	subs	r2, r2, r1
 80004fe:	1a5b      	subs	r3, r3, r1
 8000500:	4293      	cmp	r3, r2
 8000502:	d907      	bls.n	8000514 <Vector7C+0x124>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000504:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000506:	4b0a      	ldr	r3, [pc, #40]	; (8000530 <Vector7C+0x140>)
 8000508:	62e3      	str	r3, [r4, #44]	; 0x2c
 800050a:	e7fe      	b.n	800050a <Vector7C+0x11a>
 800050c:	b672      	cpsid	i
 800050e:	4b09      	ldr	r3, [pc, #36]	; (8000534 <Vector7C+0x144>)
 8000510:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000512:	e7fe      	b.n	8000512 <Vector7C+0x122>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000514:	f7ff fecc 	bl	80002b0 <_dbg_check_unlock_from_isr>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000518:	b662      	cpsie	i
 800051a:	e783      	b.n	8000424 <Vector7C+0x34>
 800051c:	20000420 	.word	0x20000420
 8000520:	08001164 	.word	0x08001164
 8000524:	0800116c 	.word	0x0800116c
 8000528:	080001cc 	.word	0x080001cc
 800052c:	080001c1 	.word	0x080001c1
 8000530:	0800123c 	.word	0x0800123c
 8000534:	08001040 	.word	0x08001040
	...

08000540 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000540:	2301      	movs	r3, #1
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000542:	2002      	movs	r0, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000544:	4927      	ldr	r1, [pc, #156]	; (80005e4 <__early_init+0xa4>)
 8000546:	680a      	ldr	r2, [r1, #0]
 8000548:	4313      	orrs	r3, r2
 800054a:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800054c:	680a      	ldr	r2, [r1, #0]
 800054e:	4b25      	ldr	r3, [pc, #148]	; (80005e4 <__early_init+0xa4>)
 8000550:	4210      	tst	r0, r2
 8000552:	d0fb      	beq.n	800054c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000554:	2103      	movs	r1, #3
 8000556:	685a      	ldr	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000558:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800055a:	438a      	bics	r2, r1
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800055c:	0019      	movs	r1, r3
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800055e:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000560:	685a      	ldr	r2, [r3, #4]
 8000562:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000564:	684b      	ldr	r3, [r1, #4]
 8000566:	4a1f      	ldr	r2, [pc, #124]	; (80005e4 <__early_init+0xa4>)
 8000568:	4003      	ands	r3, r0
 800056a:	d1fb      	bne.n	8000564 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800056c:	20f9      	movs	r0, #249	; 0xf9
 800056e:	6811      	ldr	r1, [r2, #0]
 8000570:	4001      	ands	r1, r0
 8000572:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000574:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000576:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000578:	3301      	adds	r3, #1
 800057a:	430b      	orrs	r3, r1
 800057c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800057e:	38f7      	subs	r0, #247	; 0xf7
 8000580:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000582:	4b18      	ldr	r3, [pc, #96]	; (80005e4 <__early_init+0xa4>)
 8000584:	4208      	tst	r0, r1
 8000586:	d0fb      	beq.n	8000580 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000588:	2201      	movs	r2, #1
 800058a:	6a59      	ldr	r1, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800058c:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800058e:	430a      	orrs	r2, r1
 8000590:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000592:	001a      	movs	r2, r3
 8000594:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8000596:	4b13      	ldr	r3, [pc, #76]	; (80005e4 <__early_init+0xa4>)
 8000598:	4208      	tst	r0, r1
 800059a:	d0fb      	beq.n	8000594 <__early_init+0x54>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800059c:	22a0      	movs	r2, #160	; 0xa0
 800059e:	0392      	lsls	r2, r2, #14
 80005a0:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80005a2:	2200      	movs	r2, #0
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80005a4:	2180      	movs	r1, #128	; 0x80
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80005a6:	2080      	movs	r0, #128	; 0x80
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80005a8:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 80005aa:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80005ac:	681a      	ldr	r2, [r3, #0]
 80005ae:	0449      	lsls	r1, r1, #17
 80005b0:	430a      	orrs	r2, r1
 80005b2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80005b4:	0480      	lsls	r0, r0, #18
 80005b6:	6819      	ldr	r1, [r3, #0]
 80005b8:	4a0a      	ldr	r2, [pc, #40]	; (80005e4 <__early_init+0xa4>)
 80005ba:	4201      	tst	r1, r0
 80005bc:	d0fb      	beq.n	80005b6 <__early_init+0x76>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80005be:	2111      	movs	r1, #17
 80005c0:	4b09      	ldr	r3, [pc, #36]	; (80005e8 <__early_init+0xa8>)

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80005c2:	200c      	movs	r0, #12
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80005c4:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80005c6:	2302      	movs	r3, #2
 80005c8:	6851      	ldr	r1, [r2, #4]
 80005ca:	430b      	orrs	r3, r1
 80005cc:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80005ce:	6853      	ldr	r3, [r2, #4]
 80005d0:	4904      	ldr	r1, [pc, #16]	; (80005e4 <__early_init+0xa4>)
 80005d2:	4003      	ands	r3, r0
 80005d4:	2b08      	cmp	r3, #8
 80005d6:	d1fa      	bne.n	80005ce <__early_init+0x8e>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80005d8:	698a      	ldr	r2, [r1, #24]
 80005da:	3b07      	subs	r3, #7
 80005dc:	4313      	orrs	r3, r2
 80005de:	618b      	str	r3, [r1, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 80005e0:	4770      	bx	lr
 80005e2:	46c0      	nop			; (mov r8, r8)
 80005e4:	40021000 	.word	0x40021000
 80005e8:	40022000 	.word	0x40022000
 80005ec:	00000000 	.word	0x00000000

080005f0 <chSchDoReschedule>:
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80005f0:	2320      	movs	r3, #32
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80005f2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80005f4:	4647      	mov	r7, r8
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80005f6:	4698      	mov	r8, r3
 80005f8:	4642      	mov	r2, r8
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 80005fa:	4d1d      	ldr	r5, [pc, #116]	; (8000670 <chSchDoReschedule+0x80>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80005fc:	b480      	push	{r7}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80005fe:	682f      	ldr	r7, [r5, #0]
  thread_t *otp = currp;
 8000600:	69ac      	ldr	r4, [r5, #24]

  tqp->next             = tp->queue.next;
 8000602:	683e      	ldr	r6, [r7, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000604:	3b1f      	subs	r3, #31
  tqp->next->queue.prev = (thread_t *)tqp;
 8000606:	6075      	str	r5, [r6, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000608:	602e      	str	r6, [r5, #0]
 800060a:	54bb      	strb	r3, [r7, r2]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800060c:	61af      	str	r7, [r5, #24]
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
 800060e:	f7ff fe0f 	bl	8000230 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000612:	2c00      	cmp	r4, #0
 8000614:	d024      	beq.n	8000660 <chSchDoReschedule+0x70>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000616:	4643      	mov	r3, r8
 8000618:	5ce3      	ldrb	r3, [r4, r3]
 800061a:	2b00      	cmp	r3, #0
 800061c:	d01c      	beq.n	8000658 <chSchDoReschedule+0x68>
 800061e:	2b0f      	cmp	r3, #15
 8000620:	d01a      	beq.n	8000658 <chSchDoReschedule+0x68>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000622:	2300      	movs	r3, #0
 8000624:	4642      	mov	r2, r8
 8000626:	54a3      	strb	r3, [r4, r2]
 8000628:	68a3      	ldr	r3, [r4, #8]
 800062a:	e000      	b.n	800062e <chSchDoReschedule+0x3e>
 800062c:	6836      	ldr	r6, [r6, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800062e:	68b2      	ldr	r2, [r6, #8]
 8000630:	429a      	cmp	r2, r3
 8000632:	d8fb      	bhi.n	800062c <chSchDoReschedule+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000634:	6873      	ldr	r3, [r6, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000636:	6026      	str	r6, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8000638:	6063      	str	r3, [r4, #4]
  tp->queue.prev->queue.next = tp;
 800063a:	601c      	str	r4, [r3, #0]
  cp->queue.prev             = tp;
 800063c:	6074      	str	r4, [r6, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800063e:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000642:	69e2      	ldr	r2, [r4, #28]
 8000644:	3b24      	subs	r3, #36	; 0x24
 8000646:	429a      	cmp	r2, r3
 8000648:	d80e      	bhi.n	8000668 <chSchDoReschedule+0x78>
 800064a:	0038      	movs	r0, r7
 800064c:	0021      	movs	r1, r4
 800064e:	f7ff fd9f 	bl	8000190 <_port_switch>
}
 8000652:	bc04      	pop	{r2}
 8000654:	4690      	mov	r8, r2
 8000656:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000658:	b672      	cpsid	i
 800065a:	4b06      	ldr	r3, [pc, #24]	; (8000674 <chSchDoReschedule+0x84>)
 800065c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800065e:	e7fe      	b.n	800065e <chSchDoReschedule+0x6e>
 8000660:	b672      	cpsid	i
 8000662:	4b04      	ldr	r3, [pc, #16]	; (8000674 <chSchDoReschedule+0x84>)
 8000664:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000666:	e7fe      	b.n	8000666 <chSchDoReschedule+0x76>
 8000668:	b672      	cpsid	i
 800066a:	4b03      	ldr	r3, [pc, #12]	; (8000678 <chSchDoReschedule+0x88>)
 800066c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800066e:	e7fe      	b.n	800066e <chSchDoReschedule+0x7e>
 8000670:	20000420 	.word	0x20000420
 8000674:	08001088 	.word	0x08001088
 8000678:	08001154 	.word	0x08001154
 800067c:	00000000 	.word	0x00000000

08000680 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000680:	4b06      	ldr	r3, [pc, #24]	; (800069c <_dbg_check_unlock+0x1c>)
 8000682:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000684:	2a00      	cmp	r2, #0
 8000686:	d104      	bne.n	8000692 <_dbg_check_unlock+0x12>
 8000688:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800068a:	2900      	cmp	r1, #0
 800068c:	dd01      	ble.n	8000692 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800068e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000690:	4770      	bx	lr
 8000692:	b672      	cpsid	i
 8000694:	4a02      	ldr	r2, [pc, #8]	; (80006a0 <_dbg_check_unlock+0x20>)
 8000696:	62da      	str	r2, [r3, #44]	; 0x2c
 8000698:	e7fe      	b.n	8000698 <_dbg_check_unlock+0x18>
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	20000420 	.word	0x20000420
 80006a0:	08001174 	.word	0x08001174
	...

080006b0 <chSysUnlock.lto_priv.8>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80006b0:	b510      	push	{r4, lr}

  _dbg_check_unlock();
 80006b2:	f7ff ffe5 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80006b6:	4b07      	ldr	r3, [pc, #28]	; (80006d4 <chSysUnlock.lto_priv.8+0x24>)
 80006b8:	681a      	ldr	r2, [r3, #0]
 80006ba:	429a      	cmp	r2, r3
 80006bc:	d004      	beq.n	80006c8 <chSysUnlock.lto_priv.8+0x18>
 80006be:	6999      	ldr	r1, [r3, #24]
 80006c0:	6892      	ldr	r2, [r2, #8]
 80006c2:	6889      	ldr	r1, [r1, #8]
 80006c4:	4291      	cmp	r1, r2
 80006c6:	d301      	bcc.n	80006cc <chSysUnlock.lto_priv.8+0x1c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006c8:	b662      	cpsie	i
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
}
 80006ca:	bd10      	pop	{r4, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006cc:	b672      	cpsid	i
 80006ce:	4a02      	ldr	r2, [pc, #8]	; (80006d8 <chSysUnlock.lto_priv.8+0x28>)
 80006d0:	62da      	str	r2, [r3, #44]	; 0x2c
 80006d2:	e7fe      	b.n	80006d2 <chSysUnlock.lto_priv.8+0x22>
 80006d4:	20000420 	.word	0x20000420
 80006d8:	08001058 	.word	0x08001058
 80006dc:	00000000 	.word	0x00000000

080006e0 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80006e0:	4b06      	ldr	r3, [pc, #24]	; (80006fc <_dbg_check_lock+0x1c>)
 80006e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80006e4:	2a00      	cmp	r2, #0
 80006e6:	d102      	bne.n	80006ee <_dbg_check_lock+0xe>
 80006e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80006ea:	2a00      	cmp	r2, #0
 80006ec:	d003      	beq.n	80006f6 <_dbg_check_lock+0x16>
 80006ee:	b672      	cpsid	i
 80006f0:	4a03      	ldr	r2, [pc, #12]	; (8000700 <_dbg_check_lock+0x20>)
 80006f2:	62da      	str	r2, [r3, #44]	; 0x2c
 80006f4:	e7fe      	b.n	80006f4 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80006f6:	2201      	movs	r2, #1
 80006f8:	635a      	str	r2, [r3, #52]	; 0x34
}
 80006fa:	4770      	bx	lr
 80006fc:	20000420 	.word	0x20000420
 8000700:	0800117c 	.word	0x0800117c
	...

08000710 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8000710:	b570      	push	{r4, r5, r6, lr}
 8000712:	0005      	movs	r5, r0
 8000714:	000c      	movs	r4, r1
 8000716:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000718:	f7ff ffe2 	bl	80006e0 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
 800071c:	f7ff fd88 	bl	8000230 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000720:	2c00      	cmp	r4, #0
 8000722:	d002      	beq.n	800072a <chCoreAllocAligned+0x1a>
 8000724:	1e63      	subs	r3, r4, #1
 8000726:	4223      	tst	r3, r4
 8000728:	d004      	beq.n	8000734 <chCoreAllocAligned+0x24>
 800072a:	b672      	cpsid	i
 800072c:	4a13      	ldr	r2, [pc, #76]	; (800077c <chCoreAllocAligned+0x6c>)
 800072e:	4b14      	ldr	r3, [pc, #80]	; (8000780 <chCoreAllocAligned+0x70>)
 8000730:	62da      	str	r2, [r3, #44]	; 0x2c
 8000732:	e7fe      	b.n	8000732 <chCoreAllocAligned+0x22>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8000734:	4913      	ldr	r1, [pc, #76]	; (8000784 <chCoreAllocAligned+0x74>)
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000736:	4260      	negs	r0, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8000738:	680a      	ldr	r2, [r1, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800073a:	18eb      	adds	r3, r5, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800073c:	3a01      	subs	r2, #1
 800073e:	1914      	adds	r4, r2, r4

  if (((size_t)endmem - (size_t)p) < size) {
 8000740:	4a11      	ldr	r2, [pc, #68]	; (8000788 <chCoreAllocAligned+0x78>)

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8000742:	4004      	ands	r4, r0

  if (((size_t)endmem - (size_t)p) < size) {
 8000744:	6812      	ldr	r2, [r2, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000746:	4003      	ands	r3, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8000748:	1b12      	subs	r2, r2, r4
 800074a:	4293      	cmp	r3, r2
 800074c:	d80f      	bhi.n	800076e <chCoreAllocAligned+0x5e>
    return NULL;
  }
  nextmem = p + size;
 800074e:	18e3      	adds	r3, r4, r3
 8000750:	600b      	str	r3, [r1, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000752:	f7ff ff95 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000756:	4b0a      	ldr	r3, [pc, #40]	; (8000780 <chCoreAllocAligned+0x70>)
 8000758:	681a      	ldr	r2, [r3, #0]
 800075a:	429a      	cmp	r2, r3
 800075c:	d004      	beq.n	8000768 <chCoreAllocAligned+0x58>
 800075e:	6999      	ldr	r1, [r3, #24]
 8000760:	6892      	ldr	r2, [r2, #8]
 8000762:	6889      	ldr	r1, [r1, #8]
 8000764:	4291      	cmp	r1, r2
 8000766:	d304      	bcc.n	8000772 <chCoreAllocAligned+0x62>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000768:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 800076a:	0020      	movs	r0, r4
 800076c:	bd70      	pop	{r4, r5, r6, pc}

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 800076e:	2400      	movs	r4, #0
 8000770:	e7ef      	b.n	8000752 <chCoreAllocAligned+0x42>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000772:	b672      	cpsid	i
 8000774:	4a05      	ldr	r2, [pc, #20]	; (800078c <chCoreAllocAligned+0x7c>)
 8000776:	62da      	str	r2, [r3, #44]	; 0x2c
 8000778:	e7fe      	b.n	8000778 <chCoreAllocAligned+0x68>
 800077a:	46c0      	nop			; (mov r8, r8)
 800077c:	080011b8 	.word	0x080011b8
 8000780:	20000420 	.word	0x20000420
 8000784:	200006c8 	.word	0x200006c8
 8000788:	20000578 	.word	0x20000578
 800078c:	08001070 	.word	0x08001070

08000790 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8000790:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000792:	465f      	mov	r7, fp
 8000794:	4656      	mov	r6, sl
 8000796:	464d      	mov	r5, r9
 8000798:	4644      	mov	r4, r8
 800079a:	b4f0      	push	{r4, r5, r6, r7}
 800079c:	b083      	sub	sp, #12
 800079e:	9001      	str	r0, [sp, #4]
 80007a0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80007a2:	f7ff ff9d 	bl	80006e0 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80007a6:	2222      	movs	r2, #34	; 0x22
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 80007a8:	4cad      	ldr	r4, [pc, #692]	; (8000a60 <chRegFindThreadByWorkingArea+0x2d0>)
 80007aa:	6926      	ldr	r6, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80007ac:	5cb3      	ldrb	r3, [r6, r2]
 80007ae:	3301      	adds	r3, #1
 80007b0:	54b3      	strb	r3, [r6, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80007b2:	f7ff ff65 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80007b6:	6823      	ldr	r3, [r4, #0]
 80007b8:	42a3      	cmp	r3, r4
 80007ba:	d004      	beq.n	80007c6 <chRegFindThreadByWorkingArea+0x36>
 80007bc:	69a2      	ldr	r2, [r4, #24]
 80007be:	689b      	ldr	r3, [r3, #8]
 80007c0:	6892      	ldr	r2, [r2, #8]
 80007c2:	429a      	cmp	r2, r3
 80007c4:	d340      	bcc.n	8000848 <chRegFindThreadByWorkingArea+0xb8>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80007c6:	b662      	cpsie	i
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80007c8:	9b01      	ldr	r3, [sp, #4]
 80007ca:	69f2      	ldr	r2, [r6, #28]
 80007cc:	4293      	cmp	r3, r2
 80007ce:	d100      	bne.n	80007d2 <chRegFindThreadByWorkingArea+0x42>
 80007d0:	e08b      	b.n	80008ea <chRegFindThreadByWorkingArea+0x15a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007d2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80007d4:	f7ff ff84 	bl	80006e0 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 80007d8:	6933      	ldr	r3, [r6, #16]
 80007da:	9300      	str	r3, [sp, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80007dc:	42a3      	cmp	r3, r4
 80007de:	d100      	bne.n	80007e2 <chRegFindThreadByWorkingArea+0x52>
 80007e0:	e080      	b.n	80008e4 <chRegFindThreadByWorkingArea+0x154>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80007e2:	2222      	movs	r2, #34	; 0x22
 80007e4:	5c9b      	ldrb	r3, [r3, r2]
 80007e6:	2bff      	cmp	r3, #255	; 0xff
 80007e8:	d100      	bne.n	80007ec <chRegFindThreadByWorkingArea+0x5c>
 80007ea:	e077      	b.n	80008dc <chRegFindThreadByWorkingArea+0x14c>
    ntp->refs++;
 80007ec:	9900      	ldr	r1, [sp, #0]
 80007ee:	3301      	adds	r3, #1
 80007f0:	548b      	strb	r3, [r1, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80007f2:	f7ff ff45 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80007f6:	6823      	ldr	r3, [r4, #0]
 80007f8:	42a3      	cmp	r3, r4
 80007fa:	d004      	beq.n	8000806 <chRegFindThreadByWorkingArea+0x76>
 80007fc:	69a2      	ldr	r2, [r4, #24]
 80007fe:	689b      	ldr	r3, [r3, #8]
 8000800:	6892      	ldr	r2, [r2, #8]
 8000802:	429a      	cmp	r2, r3
 8000804:	d324      	bcc.n	8000850 <chRegFindThreadByWorkingArea+0xc0>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000806:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000808:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800080a:	f7ff ff69 	bl	80006e0 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800080e:	2222      	movs	r2, #34	; 0x22
 8000810:	5cb3      	ldrb	r3, [r6, r2]
 8000812:	2b00      	cmp	r3, #0
 8000814:	d100      	bne.n	8000818 <chRegFindThreadByWorkingArea+0x88>
 8000816:	e074      	b.n	8000902 <chRegFindThreadByWorkingArea+0x172>
  tp->refs--;
 8000818:	3b01      	subs	r3, #1
 800081a:	54b3      	strb	r3, [r6, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800081c:	6a32      	ldr	r2, [r6, #32]
 800081e:	4b91      	ldr	r3, [pc, #580]	; (8000a64 <chRegFindThreadByWorkingArea+0x2d4>)
 8000820:	4013      	ands	r3, r2
 8000822:	2b0f      	cmp	r3, #15
 8000824:	d018      	beq.n	8000858 <chRegFindThreadByWorkingArea+0xc8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000826:	f7ff ff2b 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800082a:	6823      	ldr	r3, [r4, #0]
 800082c:	42a3      	cmp	r3, r4
 800082e:	d004      	beq.n	800083a <chRegFindThreadByWorkingArea+0xaa>
 8000830:	69a2      	ldr	r2, [r4, #24]
 8000832:	689b      	ldr	r3, [r3, #8]
 8000834:	6892      	ldr	r2, [r2, #8]
 8000836:	429a      	cmp	r2, r3
 8000838:	d35f      	bcc.n	80008fa <chRegFindThreadByWorkingArea+0x16a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800083a:	b662      	cpsie	i
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 800083c:	9b00      	ldr	r3, [sp, #0]
 800083e:	2b00      	cmp	r3, #0
 8000840:	d100      	bne.n	8000844 <chRegFindThreadByWorkingArea+0xb4>
 8000842:	e1a6      	b.n	8000b92 <chRegFindThreadByWorkingArea+0x402>
 8000844:	9e00      	ldr	r6, [sp, #0]
 8000846:	e7bf      	b.n	80007c8 <chRegFindThreadByWorkingArea+0x38>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000848:	b672      	cpsid	i
 800084a:	4b87      	ldr	r3, [pc, #540]	; (8000a68 <chRegFindThreadByWorkingArea+0x2d8>)
 800084c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800084e:	e7fe      	b.n	800084e <chRegFindThreadByWorkingArea+0xbe>
 8000850:	b672      	cpsid	i
 8000852:	4b85      	ldr	r3, [pc, #532]	; (8000a68 <chRegFindThreadByWorkingArea+0x2d8>)
 8000854:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000856:	e7fe      	b.n	8000856 <chRegFindThreadByWorkingArea+0xc6>
    REG_REMOVE(tp);
 8000858:	6973      	ldr	r3, [r6, #20]
 800085a:	6932      	ldr	r2, [r6, #16]
 800085c:	611a      	str	r2, [r3, #16]
 800085e:	6932      	ldr	r2, [r6, #16]
 8000860:	6153      	str	r3, [r2, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000862:	f7ff ff0d 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000866:	6823      	ldr	r3, [r4, #0]
 8000868:	42a3      	cmp	r3, r4
 800086a:	d004      	beq.n	8000876 <chRegFindThreadByWorkingArea+0xe6>
 800086c:	69a2      	ldr	r2, [r4, #24]
 800086e:	689b      	ldr	r3, [r3, #8]
 8000870:	6892      	ldr	r2, [r2, #8]
 8000872:	429a      	cmp	r2, r3
 8000874:	d349      	bcc.n	800090a <chRegFindThreadByWorkingArea+0x17a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000876:	b662      	cpsie	i
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8000878:	2321      	movs	r3, #33	; 0x21
 800087a:	2203      	movs	r2, #3
 800087c:	5cf3      	ldrb	r3, [r6, r3]
 800087e:	4013      	ands	r3, r2
 8000880:	2b01      	cmp	r3, #1
 8000882:	d021      	beq.n	80008c8 <chRegFindThreadByWorkingArea+0x138>
 8000884:	2b02      	cmp	r3, #2
 8000886:	d1d9      	bne.n	800083c <chRegFindThreadByWorkingArea+0xac>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8000888:	6c35      	ldr	r5, [r6, #64]	; 0x40
 800088a:	69f6      	ldr	r6, [r6, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800088c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800088e:	f7ff ff27 	bl	80006e0 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8000892:	f7ff fccd 	bl	8000230 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8000896:	2d00      	cmp	r5, #0
 8000898:	d012      	beq.n	80008c0 <chRegFindThreadByWorkingArea+0x130>
 800089a:	2e00      	cmp	r6, #0
 800089c:	d010      	beq.n	80008c0 <chRegFindThreadByWorkingArea+0x130>

  php->next = mp->next;
 800089e:	682b      	ldr	r3, [r5, #0]
 80008a0:	6033      	str	r3, [r6, #0]
  mp->next = php;
 80008a2:	602e      	str	r6, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80008a4:	f7ff feec 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80008a8:	6823      	ldr	r3, [r4, #0]
 80008aa:	42a3      	cmp	r3, r4
 80008ac:	d0c5      	beq.n	800083a <chRegFindThreadByWorkingArea+0xaa>
 80008ae:	69a2      	ldr	r2, [r4, #24]
 80008b0:	689b      	ldr	r3, [r3, #8]
 80008b2:	6892      	ldr	r2, [r2, #8]
 80008b4:	429a      	cmp	r2, r3
 80008b6:	d2c0      	bcs.n	800083a <chRegFindThreadByWorkingArea+0xaa>
 80008b8:	b672      	cpsid	i
 80008ba:	4b6c      	ldr	r3, [pc, #432]	; (8000a6c <chRegFindThreadByWorkingArea+0x2dc>)
 80008bc:	62e3      	str	r3, [r4, #44]	; 0x2c
 80008be:	e7fe      	b.n	80008be <chRegFindThreadByWorkingArea+0x12e>
 80008c0:	b672      	cpsid	i
 80008c2:	4b6b      	ldr	r3, [pc, #428]	; (8000a70 <chRegFindThreadByWorkingArea+0x2e0>)
 80008c4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80008c6:	e7fe      	b.n	80008c6 <chRegFindThreadByWorkingArea+0x136>
 80008c8:	69f5      	ldr	r5, [r6, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80008ca:	2d00      	cmp	r5, #0
 80008cc:	d002      	beq.n	80008d4 <chRegFindThreadByWorkingArea+0x144>
 80008ce:	2307      	movs	r3, #7
 80008d0:	421d      	tst	r5, r3
 80008d2:	d01e      	beq.n	8000912 <chRegFindThreadByWorkingArea+0x182>
 80008d4:	b672      	cpsid	i
 80008d6:	4b67      	ldr	r3, [pc, #412]	; (8000a74 <chRegFindThreadByWorkingArea+0x2e4>)
 80008d8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80008da:	e7fe      	b.n	80008da <chRegFindThreadByWorkingArea+0x14a>
 80008dc:	b672      	cpsid	i
 80008de:	4b66      	ldr	r3, [pc, #408]	; (8000a78 <chRegFindThreadByWorkingArea+0x2e8>)
 80008e0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80008e2:	e7fe      	b.n	80008e2 <chRegFindThreadByWorkingArea+0x152>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 80008e4:	2300      	movs	r3, #0
 80008e6:	9300      	str	r3, [sp, #0]
 80008e8:	e783      	b.n	80007f2 <chRegFindThreadByWorkingArea+0x62>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80008ea:	0030      	movs	r0, r6
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
 80008ec:	b003      	add	sp, #12
 80008ee:	bc3c      	pop	{r2, r3, r4, r5}
 80008f0:	4690      	mov	r8, r2
 80008f2:	4699      	mov	r9, r3
 80008f4:	46a2      	mov	sl, r4
 80008f6:	46ab      	mov	fp, r5
 80008f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80008fa:	b672      	cpsid	i
 80008fc:	4b5f      	ldr	r3, [pc, #380]	; (8000a7c <chRegFindThreadByWorkingArea+0x2ec>)
 80008fe:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000900:	e7fe      	b.n	8000900 <chRegFindThreadByWorkingArea+0x170>
 8000902:	b672      	cpsid	i
 8000904:	4b5e      	ldr	r3, [pc, #376]	; (8000a80 <chRegFindThreadByWorkingArea+0x2f0>)
 8000906:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000908:	e7fe      	b.n	8000908 <chRegFindThreadByWorkingArea+0x178>
 800090a:	b672      	cpsid	i
 800090c:	4b5b      	ldr	r3, [pc, #364]	; (8000a7c <chRegFindThreadByWorkingArea+0x2ec>)
 800090e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000910:	e7fe      	b.n	8000910 <chRegFindThreadByWorkingArea+0x180>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8000912:	2308      	movs	r3, #8
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8000914:	3d08      	subs	r5, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8000916:	682e      	ldr	r6, [r5, #0]
  qp = &heapp->header;
 8000918:	4699      	mov	r9, r3
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800091a:	0037      	movs	r7, r6
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800091c:	686b      	ldr	r3, [r5, #4]

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 800091e:	44b1      	add	r9, r6

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8000920:	3307      	adds	r3, #7
 8000922:	08db      	lsrs	r3, r3, #3
 8000924:	606b      	str	r3, [r5, #4]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8000926:	3710      	adds	r7, #16
 8000928:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800092a:	f7ff fed9 	bl	80006e0 <_dbg_check_lock>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800092e:	69a3      	ldr	r3, [r4, #24]
 8000930:	469a      	mov	sl, r3

  chDbgCheckClassS();
 8000932:	f7ff fc6d 	bl	8000210 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8000936:	2f00      	cmp	r7, #0
 8000938:	d100      	bne.n	800093c <chRegFindThreadByWorkingArea+0x1ac>
 800093a:	e126      	b.n	8000b8a <chRegFindThreadByWorkingArea+0x3fa>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800093c:	69b0      	ldr	r0, [r6, #24]
 800093e:	2800      	cmp	r0, #0
 8000940:	d037      	beq.n	80009b2 <chRegFindThreadByWorkingArea+0x222>
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000942:	2320      	movs	r3, #32
 8000944:	469c      	mov	ip, r3
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000946:	4653      	mov	r3, sl
 8000948:	689a      	ldr	r2, [r3, #8]
 800094a:	6883      	ldr	r3, [r0, #8]
 800094c:	429a      	cmp	r2, r3
 800094e:	d914      	bls.n	800097a <chRegFindThreadByWorkingArea+0x1ea>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000950:	4663      	mov	r3, ip

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8000952:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000954:	5cc3      	ldrb	r3, [r0, r3]
 8000956:	2b06      	cmp	r3, #6
 8000958:	d100      	bne.n	800095c <chRegFindThreadByWorkingArea+0x1cc>
 800095a:	e101      	b.n	8000b60 <chRegFindThreadByWorkingArea+0x3d0>
 800095c:	2b07      	cmp	r3, #7
 800095e:	d100      	bne.n	8000962 <chRegFindThreadByWorkingArea+0x1d2>
 8000960:	e0ea      	b.n	8000b38 <chRegFindThreadByWorkingArea+0x3a8>
 8000962:	2b00      	cmp	r3, #0
 8000964:	d109      	bne.n	800097a <chRegFindThreadByWorkingArea+0x1ea>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8000966:	2201      	movs	r2, #1
 8000968:	2320      	movs	r3, #32
 800096a:	54c2      	strb	r2, [r0, r3]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800096c:	6802      	ldr	r2, [r0, #0]
 800096e:	6843      	ldr	r3, [r0, #4]
 8000970:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000972:	6802      	ldr	r2, [r0, #0]
 8000974:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000976:	f7ff fc6b 	bl	8000250 <chSchReadyI>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800097a:	003b      	movs	r3, r7
 800097c:	4652      	mov	r2, sl
  do {
    cp = cp->queue.next;
 800097e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000980:	429f      	cmp	r7, r3
 8000982:	d003      	beq.n	800098c <chRegFindThreadByWorkingArea+0x1fc>
 8000984:	6899      	ldr	r1, [r3, #8]
 8000986:	6890      	ldr	r0, [r2, #8]
 8000988:	4281      	cmp	r1, r0
 800098a:	d2f8      	bcs.n	800097e <chRegFindThreadByWorkingArea+0x1ee>
 800098c:	4692      	mov	sl, r2
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800098e:	4651      	mov	r1, sl

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000990:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8000992:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000994:	2006      	movs	r0, #6
 8000996:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000998:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 800099a:	6059      	str	r1, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 800099c:	624f      	str	r7, [r1, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800099e:	f7ff fcff 	bl	80003a0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 80009a2:	69b3      	ldr	r3, [r6, #24]
 80009a4:	459a      	cmp	sl, r3
 80009a6:	d100      	bne.n	80009aa <chRegFindThreadByWorkingArea+0x21a>
 80009a8:	e0f5      	b.n	8000b96 <chRegFindThreadByWorkingArea+0x406>
 80009aa:	b672      	cpsid	i
 80009ac:	4b35      	ldr	r3, [pc, #212]	; (8000a84 <chRegFindThreadByWorkingArea+0x2f4>)
 80009ae:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009b0:	e7fe      	b.n	80009b0 <chRegFindThreadByWorkingArea+0x220>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80009b2:	4653      	mov	r3, sl
 80009b4:	61b3      	str	r3, [r6, #24]
    mp->next = ctp->mtxlist;
 80009b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80009b8:	61f3      	str	r3, [r6, #28]
    ctp->mtxlist = mp;
 80009ba:	4653      	mov	r3, sl
 80009bc:	639f      	str	r7, [r3, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80009be:	f7ff fe5f 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80009c2:	6823      	ldr	r3, [r4, #0]
 80009c4:	42a3      	cmp	r3, r4
 80009c6:	d005      	beq.n	80009d4 <chRegFindThreadByWorkingArea+0x244>
 80009c8:	69a2      	ldr	r2, [r4, #24]
 80009ca:	689b      	ldr	r3, [r3, #8]
 80009cc:	6892      	ldr	r2, [r2, #8]
 80009ce:	429a      	cmp	r2, r3
 80009d0:	d200      	bcs.n	80009d4 <chRegFindThreadByWorkingArea+0x244>
 80009d2:	e0ed      	b.n	8000bb0 <chRegFindThreadByWorkingArea+0x420>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009d4:	b662      	cpsie	i

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80009d6:	464b      	mov	r3, r9
 80009d8:	4649      	mov	r1, r9

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80009da:	429d      	cmp	r5, r3
 80009dc:	d306      	bcc.n	80009ec <chRegFindThreadByWorkingArea+0x25c>
 80009de:	685a      	ldr	r2, [r3, #4]
 80009e0:	3201      	adds	r2, #1
 80009e2:	00d2      	lsls	r2, r2, #3
 80009e4:	189a      	adds	r2, r3, r2
 80009e6:	4295      	cmp	r5, r2
 80009e8:	d200      	bcs.n	80009ec <chRegFindThreadByWorkingArea+0x25c>
 80009ea:	e0dd      	b.n	8000ba8 <chRegFindThreadByWorkingArea+0x418>

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80009ec:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80009ee:	4299      	cmp	r1, r3
 80009f0:	d001      	beq.n	80009f6 <chRegFindThreadByWorkingArea+0x266>
 80009f2:	429d      	cmp	r5, r3
 80009f4:	d903      	bls.n	80009fe <chRegFindThreadByWorkingArea+0x26e>
 80009f6:	2a00      	cmp	r2, #0
 80009f8:	d003      	beq.n	8000a02 <chRegFindThreadByWorkingArea+0x272>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80009fa:	4295      	cmp	r5, r2
 80009fc:	d301      	bcc.n	8000a02 <chRegFindThreadByWorkingArea+0x272>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 80009fe:	0013      	movs	r3, r2
 8000a00:	e7eb      	b.n	80009da <chRegFindThreadByWorkingArea+0x24a>
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8000a02:	602a      	str	r2, [r5, #0]
      H_NEXT(qp) = hp;
 8000a04:	601d      	str	r5, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8000a06:	6869      	ldr	r1, [r5, #4]
 8000a08:	6828      	ldr	r0, [r5, #0]
 8000a0a:	1c4a      	adds	r2, r1, #1
 8000a0c:	00d2      	lsls	r2, r2, #3
 8000a0e:	18aa      	adds	r2, r5, r2
 8000a10:	4282      	cmp	r2, r0
 8000a12:	d106      	bne.n	8000a22 <chRegFindThreadByWorkingArea+0x292>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8000a14:	6850      	ldr	r0, [r2, #4]
 8000a16:	4684      	mov	ip, r0
 8000a18:	4461      	add	r1, ip
 8000a1a:	3101      	adds	r1, #1
 8000a1c:	6069      	str	r1, [r5, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8000a1e:	6812      	ldr	r2, [r2, #0]
 8000a20:	602a      	str	r2, [r5, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8000a22:	6859      	ldr	r1, [r3, #4]
 8000a24:	1c4a      	adds	r2, r1, #1
 8000a26:	00d2      	lsls	r2, r2, #3
 8000a28:	189a      	adds	r2, r3, r2
 8000a2a:	4295      	cmp	r5, r2
 8000a2c:	d100      	bne.n	8000a30 <chRegFindThreadByWorkingArea+0x2a0>
 8000a2e:	e07a      	b.n	8000b26 <chRegFindThreadByWorkingArea+0x396>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000a30:	69a3      	ldr	r3, [r4, #24]
 8000a32:	469a      	mov	sl, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a34:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000a36:	f7ff fe53 	bl	80006e0 <_dbg_check_lock>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8000a3a:	4653      	mov	r3, sl
 8000a3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000a3e:	2b00      	cmp	r3, #0
 8000a40:	d06d      	beq.n	8000b1e <chRegFindThreadByWorkingArea+0x38e>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8000a42:	689a      	ldr	r2, [r3, #8]
 8000a44:	4693      	mov	fp, r2
 8000a46:	4552      	cmp	r2, sl
 8000a48:	d003      	beq.n	8000a52 <chRegFindThreadByWorkingArea+0x2c2>
 8000a4a:	b672      	cpsid	i
 8000a4c:	4b0e      	ldr	r3, [pc, #56]	; (8000a88 <chRegFindThreadByWorkingArea+0x2f8>)
 8000a4e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000a50:	e7fe      	b.n	8000a50 <chRegFindThreadByWorkingArea+0x2c0>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8000a52:	429f      	cmp	r7, r3
 8000a54:	d01a      	beq.n	8000a8c <chRegFindThreadByWorkingArea+0x2fc>
 8000a56:	b672      	cpsid	i
 8000a58:	4b0b      	ldr	r3, [pc, #44]	; (8000a88 <chRegFindThreadByWorkingArea+0x2f8>)
 8000a5a:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000a5c:	e7fe      	b.n	8000a5c <chRegFindThreadByWorkingArea+0x2cc>
 8000a5e:	46c0      	nop			; (mov r8, r8)
 8000a60:	20000420 	.word	0x20000420
 8000a64:	00ff00ff 	.word	0x00ff00ff
 8000a68:	080011f0 	.word	0x080011f0
 8000a6c:	0800107c 	.word	0x0800107c
 8000a70:	080011d8 	.word	0x080011d8
 8000a74:	080011fc 	.word	0x080011fc
 8000a78:	0800109c 	.word	0x0800109c
 8000a7c:	08001058 	.word	0x08001058
 8000a80:	0800122c 	.word	0x0800122c
 8000a84:	080011cc 	.word	0x080011cc
 8000a88:	080011e4 	.word	0x080011e4

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000a8c:	69f3      	ldr	r3, [r6, #28]
 8000a8e:	4699      	mov	r9, r3
 8000a90:	4653      	mov	r3, sl
 8000a92:	464a      	mov	r2, r9
 8000a94:	639a      	str	r2, [r3, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8000a96:	f7ff fbbb 	bl	8000210 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000a9a:	6935      	ldr	r5, [r6, #16]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000a9c:	42af      	cmp	r7, r5
 8000a9e:	d03b      	beq.n	8000b18 <chRegFindThreadByWorkingArea+0x388>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000aa0:	4653      	mov	r3, sl
 8000aa2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000aa4:	46a8      	mov	r8, r5
 8000aa6:	469a      	mov	sl, r3
 8000aa8:	464d      	mov	r5, r9
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000aaa:	2d00      	cmp	r5, #0
 8000aac:	d00a      	beq.n	8000ac4 <chRegFindThreadByWorkingArea+0x334>
 8000aae:	f7ff fbaf 	bl	8000210 <chDbgCheckClassS>
 8000ab2:	682b      	ldr	r3, [r5, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000ab4:	429d      	cmp	r5, r3
 8000ab6:	d003      	beq.n	8000ac0 <chRegFindThreadByWorkingArea+0x330>
            (lmp->queue.next->prio > newprio)) {
 8000ab8:	689b      	ldr	r3, [r3, #8]
 8000aba:	459a      	cmp	sl, r3
 8000abc:	d200      	bcs.n	8000ac0 <chRegFindThreadByWorkingArea+0x330>
 8000abe:	469a      	mov	sl, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000ac0:	68ed      	ldr	r5, [r5, #12]
 8000ac2:	e7f2      	b.n	8000aaa <chRegFindThreadByWorkingArea+0x31a>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8000ac4:	4652      	mov	r2, sl
 8000ac6:	4645      	mov	r5, r8
 8000ac8:	465b      	mov	r3, fp
 8000aca:	609a      	str	r2, [r3, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000acc:	682b      	ldr	r3, [r5, #0]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000ace:	4640      	mov	r0, r8
 8000ad0:	6133      	str	r3, [r6, #16]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ad2:	605f      	str	r7, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000ad4:	6bab      	ldr	r3, [r5, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8000ad6:	61b5      	str	r5, [r6, #24]
      mp->next = tp->mtxlist;
 8000ad8:	61f3      	str	r3, [r6, #28]
      tp->mtxlist = mp;
 8000ada:	63af      	str	r7, [r5, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000adc:	f7ff fbb8 	bl	8000250 <chSchReadyI>
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
 8000ae0:	f7ff fb96 	bl	8000210 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8000ae4:	f7ff fba4 	bl	8000230 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000ae8:	6822      	ldr	r2, [r4, #0]
 8000aea:	69a3      	ldr	r3, [r4, #24]

  if (chSchIsRescRequiredI()) {
 8000aec:	6892      	ldr	r2, [r2, #8]
 8000aee:	689b      	ldr	r3, [r3, #8]
 8000af0:	429a      	cmp	r2, r3
 8000af2:	d901      	bls.n	8000af8 <chRegFindThreadByWorkingArea+0x368>
    chSchDoRescheduleAhead();
 8000af4:	f7ff fd7c 	bl	80005f0 <chSchDoReschedule>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000af8:	f7ff fdc2 	bl	8000680 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000afc:	6823      	ldr	r3, [r4, #0]
 8000afe:	42a3      	cmp	r3, r4
 8000b00:	d100      	bne.n	8000b04 <chRegFindThreadByWorkingArea+0x374>
 8000b02:	e69a      	b.n	800083a <chRegFindThreadByWorkingArea+0xaa>
 8000b04:	69a2      	ldr	r2, [r4, #24]
 8000b06:	689b      	ldr	r3, [r3, #8]
 8000b08:	6892      	ldr	r2, [r2, #8]
 8000b0a:	429a      	cmp	r2, r3
 8000b0c:	d300      	bcc.n	8000b10 <chRegFindThreadByWorkingArea+0x380>
 8000b0e:	e694      	b.n	800083a <chRegFindThreadByWorkingArea+0xaa>
 8000b10:	b672      	cpsid	i
 8000b12:	4b29      	ldr	r3, [pc, #164]	; (8000bb8 <chRegFindThreadByWorkingArea+0x428>)
 8000b14:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000b16:	e7fe      	b.n	8000b16 <chRegFindThreadByWorkingArea+0x386>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8000b18:	2300      	movs	r3, #0
 8000b1a:	61b3      	str	r3, [r6, #24]
 8000b1c:	e7ec      	b.n	8000af8 <chRegFindThreadByWorkingArea+0x368>
 8000b1e:	b672      	cpsid	i
 8000b20:	4b26      	ldr	r3, [pc, #152]	; (8000bbc <chRegFindThreadByWorkingArea+0x42c>)
 8000b22:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000b24:	e7fe      	b.n	8000b24 <chRegFindThreadByWorkingArea+0x394>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8000b26:	686a      	ldr	r2, [r5, #4]
 8000b28:	188a      	adds	r2, r1, r2
 8000b2a:	3201      	adds	r2, #1
 8000b2c:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8000b2e:	682a      	ldr	r2, [r5, #0]
 8000b30:	601a      	str	r2, [r3, #0]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000b32:	69a3      	ldr	r3, [r4, #24]
 8000b34:	469a      	mov	sl, r3
 8000b36:	e77d      	b.n	8000a34 <chRegFindThreadByWorkingArea+0x2a4>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000b38:	6843      	ldr	r3, [r0, #4]
 8000b3a:	6801      	ldr	r1, [r0, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000b3c:	4694      	mov	ip, r2
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000b3e:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000b40:	6801      	ldr	r1, [r0, #0]
 8000b42:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000b44:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000b46:	000b      	movs	r3, r1
  do {
    cp = cp->queue.next;
 8000b48:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000b4a:	4299      	cmp	r1, r3
 8000b4c:	d002      	beq.n	8000b54 <chRegFindThreadByWorkingArea+0x3c4>
 8000b4e:	689a      	ldr	r2, [r3, #8]
 8000b50:	4594      	cmp	ip, r2
 8000b52:	d9f9      	bls.n	8000b48 <chRegFindThreadByWorkingArea+0x3b8>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000b54:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000b56:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000b58:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000b5a:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000b5c:	6058      	str	r0, [r3, #4]
 8000b5e:	e70c      	b.n	800097a <chRegFindThreadByWorkingArea+0x1ea>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000b60:	6841      	ldr	r1, [r0, #4]
 8000b62:	6803      	ldr	r3, [r0, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000b64:	4690      	mov	r8, r2
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000b66:	600b      	str	r3, [r1, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000b68:	6803      	ldr	r3, [r0, #0]
 8000b6a:	6059      	str	r1, [r3, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000b6c:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000b6e:	000b      	movs	r3, r1
  do {
    cp = cp->queue.next;
 8000b70:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000b72:	4299      	cmp	r1, r3
 8000b74:	d002      	beq.n	8000b7c <chRegFindThreadByWorkingArea+0x3ec>
 8000b76:	689a      	ldr	r2, [r3, #8]
 8000b78:	4590      	cmp	r8, r2
 8000b7a:	d9f9      	bls.n	8000b70 <chRegFindThreadByWorkingArea+0x3e0>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000b7c:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000b7e:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000b80:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000b82:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000b84:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8000b86:	6888      	ldr	r0, [r1, #8]
 8000b88:	e6dd      	b.n	8000946 <chRegFindThreadByWorkingArea+0x1b6>
 8000b8a:	b672      	cpsid	i
 8000b8c:	4b0c      	ldr	r3, [pc, #48]	; (8000bc0 <chRegFindThreadByWorkingArea+0x430>)
 8000b8e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000b90:	e7fe      	b.n	8000b90 <chRegFindThreadByWorkingArea+0x400>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
 8000b92:	0018      	movs	r0, r3
 8000b94:	e6aa      	b.n	80008ec <chRegFindThreadByWorkingArea+0x15c>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8000b96:	4653      	mov	r3, sl
 8000b98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000b9a:	429f      	cmp	r7, r3
 8000b9c:	d100      	bne.n	8000ba0 <chRegFindThreadByWorkingArea+0x410>
 8000b9e:	e70e      	b.n	80009be <chRegFindThreadByWorkingArea+0x22e>
 8000ba0:	b672      	cpsid	i
 8000ba2:	4b07      	ldr	r3, [pc, #28]	; (8000bc0 <chRegFindThreadByWorkingArea+0x430>)
 8000ba4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000ba6:	e7fe      	b.n	8000ba6 <chRegFindThreadByWorkingArea+0x416>
 8000ba8:	b672      	cpsid	i
 8000baa:	4b06      	ldr	r3, [pc, #24]	; (8000bc4 <chRegFindThreadByWorkingArea+0x434>)
 8000bac:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000bae:	e7fe      	b.n	8000bae <chRegFindThreadByWorkingArea+0x41e>
 8000bb0:	b672      	cpsid	i
 8000bb2:	4b01      	ldr	r3, [pc, #4]	; (8000bb8 <chRegFindThreadByWorkingArea+0x428>)
 8000bb4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000bb6:	e7fe      	b.n	8000bb6 <chRegFindThreadByWorkingArea+0x426>
 8000bb8:	08001064 	.word	0x08001064
 8000bbc:	080011e4 	.word	0x080011e4
 8000bc0:	080011cc 	.word	0x080011cc
 8000bc4:	080011fc 	.word	0x080011fc
	...

08000bd0 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000bd0:	4bba      	ldr	r3, [pc, #744]	; (8000ebc <main+0x2ec>)
 8000bd2:	2101      	movs	r1, #1
 8000bd4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000bd6:	2200      	movs	r2, #0
 8000bd8:	4249      	negs	r1, r1
}

/*
 * Application entry point.
 */
int main(void) {
 8000bda:	b570      	push	{r4, r5, r6, lr}
 8000bdc:	6299      	str	r1, [r3, #40]	; 0x28
 8000bde:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000be0:	6918      	ldr	r0, [r3, #16]
 8000be2:	6119      	str	r1, [r3, #16]
 8000be4:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000be6:	68d9      	ldr	r1, [r3, #12]
 8000be8:	48b5      	ldr	r0, [pc, #724]	; (8000ec0 <main+0x2f0>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000bea:	2480      	movs	r4, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000bec:	4301      	orrs	r1, r0

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000bee:	2080      	movs	r0, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000bf0:	60d9      	str	r1, [r3, #12]
 8000bf2:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000bf4:	69d9      	ldr	r1, [r3, #28]
 8000bf6:	0540      	lsls	r0, r0, #21
 8000bf8:	4301      	orrs	r1, r0
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000bfa:	48b2      	ldr	r0, [pc, #712]	; (8000ec4 <main+0x2f4>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000bfc:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000bfe:	6801      	ldr	r1, [r0, #0]
 8000c00:	0064      	lsls	r4, r4, #1
 8000c02:	4321      	orrs	r1, r4
 8000c04:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8000c06:	21c0      	movs	r1, #192	; 0xc0
 8000c08:	6a18      	ldr	r0, [r3, #32]
 8000c0a:	0089      	lsls	r1, r1, #2
 8000c0c:	4001      	ands	r1, r0
 8000c0e:	2080      	movs	r0, #128	; 0x80
 8000c10:	0080      	lsls	r0, r0, #2
 8000c12:	4281      	cmp	r1, r0
 8000c14:	d003      	beq.n	8000c1e <main+0x4e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000c16:	2180      	movs	r1, #128	; 0x80
 8000c18:	0249      	lsls	r1, r1, #9
 8000c1a:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8000c1c:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000c1e:	2080      	movs	r0, #128	; 0x80
 8000c20:	4ba6      	ldr	r3, [pc, #664]	; (8000ebc <main+0x2ec>)
 8000c22:	0200      	lsls	r0, r0, #8
 8000c24:	6a1a      	ldr	r2, [r3, #32]
 8000c26:	4202      	tst	r2, r0
 8000c28:	d107      	bne.n	8000c3a <main+0x6a>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000c2a:	2280      	movs	r2, #128	; 0x80
 8000c2c:	6a19      	ldr	r1, [r3, #32]
 8000c2e:	0092      	lsls	r2, r2, #2
 8000c30:	4311      	orrs	r1, r2
 8000c32:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000c34:	6a1a      	ldr	r2, [r3, #32]
 8000c36:	4302      	orrs	r2, r0
 8000c38:	621a      	str	r2, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000c3a:	229c      	movs	r2, #156	; 0x9c
 8000c3c:	4c9f      	ldr	r4, [pc, #636]	; (8000ebc <main+0x2ec>)
 8000c3e:	03d2      	lsls	r2, r2, #15
 8000c40:	6963      	ldr	r3, [r4, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000c42:	2001      	movs	r0, #1
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000c44:	4313      	orrs	r3, r2
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c46:	2290      	movs	r2, #144	; 0x90
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000c48:	6163      	str	r3, [r4, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c4a:	2300      	movs	r3, #0
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000c4c:	499e      	ldr	r1, [pc, #632]	; (8000ec8 <main+0x2f8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c4e:	05d2      	lsls	r2, r2, #23
  gpiop->OSPEEDR = config->ospeedr;
 8000c50:	4240      	negs	r0, r0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c52:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c54:	6090      	str	r0, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c56:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8000c58:	499c      	ldr	r1, [pc, #624]	; (8000ecc <main+0x2fc>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000c5a:	2580      	movs	r5, #128	; 0x80
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000c5c:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000c5e:	499c      	ldr	r1, [pc, #624]	; (8000ed0 <main+0x300>)
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000c60:	02ad      	lsls	r5, r5, #10

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000c62:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000c64:	499b      	ldr	r1, [pc, #620]	; (8000ed4 <main+0x304>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8000c66:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000c68:	6011      	str	r1, [r2, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000c6a:	21c0      	movs	r1, #192	; 0xc0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c6c:	4a9a      	ldr	r2, [pc, #616]	; (8000ed8 <main+0x308>)
  gpiop->OSPEEDR = config->ospeedr;
 8000c6e:	0289      	lsls	r1, r1, #10
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c70:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c72:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c74:	4999      	ldr	r1, [pc, #612]	; (8000edc <main+0x30c>)
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000c76:	2680      	movs	r6, #128	; 0x80
 8000c78:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8000c7a:	4999      	ldr	r1, [pc, #612]	; (8000ee0 <main+0x310>)
 8000c7c:	0636      	lsls	r6, r6, #24
 8000c7e:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000c80:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000c82:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000c84:	6015      	str	r5, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c86:	4a97      	ldr	r2, [pc, #604]	; (8000ee4 <main+0x314>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000c88:	4d97      	ldr	r5, [pc, #604]	; (8000ee8 <main+0x318>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c8a:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c8c:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c8e:	60d5      	str	r5, [r2, #12]
  gpiop->ODR     = config->odr;
 8000c90:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000c92:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000c94:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000c96:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c98:	4a94      	ldr	r2, [pc, #592]	; (8000eec <main+0x31c>)
 8000c9a:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c9c:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c9e:	60d5      	str	r5, [r2, #12]
  gpiop->ODR     = config->odr;
 8000ca0:	6151      	str	r1, [r2, #20]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000ca2:	2101      	movs	r1, #1
  gpiop->AFRL    = config->afrl;
 8000ca4:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000ca6:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000ca8:	6013      	str	r3, [r2, #0]
 8000caa:	69e2      	ldr	r2, [r4, #28]
 8000cac:	25c3      	movs	r5, #195	; 0xc3
 8000cae:	430a      	orrs	r2, r1
 8000cb0:	61e2      	str	r2, [r4, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000cb2:	4c8f      	ldr	r4, [pc, #572]	; (8000ef0 <main+0x320>)
 8000cb4:	00ad      	lsls	r5, r5, #2
 8000cb6:	68a2      	ldr	r2, [r4, #8]
 8000cb8:	430a      	orrs	r2, r1
 8000cba:	60a2      	str	r2, [r4, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000cbc:	2280      	movs	r2, #128	; 0x80
 8000cbe:	4c8d      	ldr	r4, [pc, #564]	; (8000ef4 <main+0x324>)
 8000cc0:	05d2      	lsls	r2, r2, #23
 8000cc2:	6294      	str	r4, [r2, #40]	; 0x28
 8000cc4:	4c8c      	ldr	r4, [pc, #560]	; (8000ef8 <main+0x328>)
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000cc6:	62d0      	str	r0, [r2, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000cc8:	6193      	str	r3, [r2, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8000cca:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000ccc:	60d3      	str	r3, [r2, #12]
  STM32_ST_TIM->CR2    = 0;
 8000cce:	6053      	str	r3, [r2, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000cd0:	6151      	str	r1, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000cd2:	6011      	str	r1, [r2, #0]
 8000cd4:	5962      	ldr	r2, [r4, r5]
 8000cd6:	0212      	lsls	r2, r2, #8
 8000cd8:	0a12      	lsrs	r2, r2, #8
 8000cda:	4332      	orrs	r2, r6
 8000cdc:	5162      	str	r2, [r4, r5]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000cde:	2280      	movs	r2, #128	; 0x80
 8000ce0:	3d8d      	subs	r5, #141	; 0x8d
 8000ce2:	0212      	lsls	r2, r2, #8
 8000ce4:	3dff      	subs	r5, #255	; 0xff
 8000ce6:	5162      	str	r2, [r4, r5]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000ce8:	6022      	str	r2, [r4, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000cea:	4c84      	ldr	r4, [pc, #528]	; (8000efc <main+0x32c>)
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000cec:	0022      	movs	r2, r4
 8000cee:	321c      	adds	r2, #28
 8000cf0:	61e2      	str	r2, [r4, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000cf2:	6222      	str	r2, [r4, #32]
  ch.vtlist.delta = (systime_t)-1;
 8000cf4:	6260      	str	r0, [r4, #36]	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8000cf6:	4a82      	ldr	r2, [pc, #520]	; (8000f00 <main+0x330>)
 8000cf8:	4882      	ldr	r0, [pc, #520]	; (8000f04 <main+0x334>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000cfa:	60a3      	str	r3, [r4, #8]
 8000cfc:	6010      	str	r0, [r2, #0]
  endmem  = __heap_end__;
 8000cfe:	4882      	ldr	r0, [pc, #520]	; (8000f08 <main+0x338>)
 8000d00:	4a82      	ldr	r2, [pc, #520]	; (8000f0c <main+0x33c>)
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8000d02:	62a3      	str	r3, [r4, #40]	; 0x28
 8000d04:	6010      	str	r0, [r2, #0]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8000d06:	4a82      	ldr	r2, [pc, #520]	; (8000f10 <main+0x340>)
 8000d08:	4882      	ldr	r0, [pc, #520]	; (8000f14 <main+0x344>)
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8000d0a:	6323      	str	r3, [r4, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8000d0c:	6363      	str	r3, [r4, #52]	; 0x34
 8000d0e:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
 8000d10:	6064      	str	r4, [r4, #4]
 8000d12:	6010      	str	r0, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000d14:	0010      	movs	r0, r2
 8000d16:	3010      	adds	r0, #16
 8000d18:	6110      	str	r0, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 8000d1a:	6150      	str	r0, [r2, #20]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000d1c:	2059      	movs	r0, #89	; 0x59
  H_NEXT(&default_heap.header) = NULL;
 8000d1e:	6093      	str	r3, [r2, #8]
  H_PAGES(&default_heap.header) = 0;
 8000d20:	60d3      	str	r3, [r2, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000d22:	6193      	str	r3, [r2, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000d24:	2280      	movs	r2, #128	; 0x80
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000d26:	5423      	strb	r3, [r4, r0]
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000d28:	66e3      	str	r3, [r4, #108]	; 0x6c
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000d2a:	6723      	str	r3, [r4, #112]	; 0x70
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000d2c:	335a      	adds	r3, #90	; 0x5a
 8000d2e:	54e1      	strb	r1, [r4, r3]
  tp->name      = name;
 8000d30:	4b79      	ldr	r3, [pc, #484]	; (8000f18 <main+0x348>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000d32:	6422      	str	r2, [r4, #64]	; 0x40
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000d34:	6762      	str	r2, [r4, #116]	; 0x74
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000d36:	6523      	str	r3, [r4, #80]	; 0x50
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000d38:	0022      	movs	r2, r4
  REG_INSERT(tp);
 8000d3a:	0023      	movs	r3, r4
 8000d3c:	3260      	adds	r2, #96	; 0x60
 8000d3e:	3338      	adds	r3, #56	; 0x38
 8000d40:	6123      	str	r3, [r4, #16]
 8000d42:	6163      	str	r3, [r4, #20]
 8000d44:	6622      	str	r2, [r4, #96]	; 0x60
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8000d46:	61a3      	str	r3, [r4, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000d48:	0022      	movs	r2, r4
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8000d4a:	4b74      	ldr	r3, [pc, #464]	; (8000f1c <main+0x34c>)
 8000d4c:	3264      	adds	r2, #100	; 0x64
 8000d4e:	6563      	str	r3, [r4, #84]	; 0x54
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000d50:	2358      	movs	r3, #88	; 0x58
 8000d52:	6662      	str	r2, [r4, #100]	; 0x64
  tqp->prev = (thread_t *)tqp;
 8000d54:	66a2      	str	r2, [r4, #104]	; 0x68
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000d56:	4a72      	ldr	r2, [pc, #456]	; (8000f20 <main+0x350>)
 8000d58:	54e1      	strb	r1, [r4, r3]
 8000d5a:	6a11      	ldr	r1, [r2, #32]
 8000d5c:	4b71      	ldr	r3, [pc, #452]	; (8000f24 <main+0x354>)
 8000d5e:	64a4      	str	r4, [r4, #72]	; 0x48
 8000d60:	400b      	ands	r3, r1
 8000d62:	64e4      	str	r4, [r4, #76]	; 0x4c
 8000d64:	6213      	str	r3, [r2, #32]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d66:	b662      	cpsie	i
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8000d68:	4d6f      	ldr	r5, [pc, #444]	; (8000f28 <main+0x358>)
 8000d6a:	0028      	movs	r0, r5
 8000d6c:	f7ff fd10 	bl	8000790 <chRegFindThreadByWorkingArea>
 8000d70:	2800      	cmp	r0, #0
 8000d72:	d003      	beq.n	8000d7c <main+0x1ac>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d74:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000d76:	4b6d      	ldr	r3, [pc, #436]	; (8000f2c <main+0x35c>)
 8000d78:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000d7a:	e7fe      	b.n	8000d7a <main+0x1aa>
 8000d7c:	0029      	movs	r1, r5
 8000d7e:	002b      	movs	r3, r5
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000d80:	2255      	movs	r2, #85	; 0x55
 8000d82:	31d8      	adds	r1, #216	; 0xd8
 8000d84:	701a      	strb	r2, [r3, #0]
 8000d86:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000d88:	4299      	cmp	r1, r3
 8000d8a:	d1fb      	bne.n	8000d84 <main+0x1b4>
 8000d8c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000d8e:	f7ff fca7 	bl	80006e0 <_dbg_check_lock>
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
 8000d92:	f7ff fa4d 	bl	8000230 <chDbgCheckClassI>
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000d96:	23ac      	movs	r3, #172	; 0xac
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000d98:	002a      	movs	r2, r5
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000d9a:	50ed      	str	r5, [r5, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000d9c:	326c      	adds	r2, #108	; 0x6c
 8000d9e:	3b10      	subs	r3, #16
 8000da0:	50ea      	str	r2, [r5, r3]
 8000da2:	4b63      	ldr	r3, [pc, #396]	; (8000f30 <main+0x360>)
 8000da4:	2280      	movs	r2, #128	; 0x80
 8000da6:	67eb      	str	r3, [r5, #124]	; 0x7c
 8000da8:	2300      	movs	r3, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000daa:	2198      	movs	r1, #152	; 0x98
  tp->state     = CH_STATE_WTSTART;
 8000dac:	2002      	movs	r0, #2
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000dae:	4e61      	ldr	r6, [pc, #388]	; (8000f34 <main+0x364>)
 8000db0:	50ab      	str	r3, [r5, r2]
 8000db2:	320c      	adds	r2, #12
 8000db4:	50ae      	str	r6, [r5, r2]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000db6:	3a8b      	subs	r2, #139	; 0x8b
 8000db8:	506a      	str	r2, [r5, r1]
  tp->state     = CH_STATE_WTSTART;
 8000dba:	3118      	adds	r1, #24
 8000dbc:	5468      	strb	r0, [r5, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000dbe:	3101      	adds	r1, #1
 8000dc0:	546b      	strb	r3, [r5, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000dc2:	311b      	adds	r1, #27
 8000dc4:	506a      	str	r2, [r5, r1]
  tp->mtxlist   = NULL;
 8000dc6:	3904      	subs	r1, #4
 8000dc8:	506b      	str	r3, [r5, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000dca:	3904      	subs	r1, #4
 8000dcc:	506b      	str	r3, [r5, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000dce:	33b2      	adds	r3, #178	; 0xb2
 8000dd0:	54ea      	strb	r2, [r5, r3]
  tp->name      = name;
 8000dd2:	4a59      	ldr	r2, [pc, #356]	; (8000f38 <main+0x368>)
 8000dd4:	3b0a      	subs	r3, #10
 8000dd6:	50ea      	str	r2, [r5, r3]
  REG_INSERT(tp);
 8000dd8:	0028      	movs	r0, r5
 8000dda:	22a4      	movs	r2, #164	; 0xa4
 8000ddc:	3b08      	subs	r3, #8
 8000dde:	50ec      	str	r4, [r5, r3]
 8000de0:	6963      	ldr	r3, [r4, #20]
 8000de2:	3090      	adds	r0, #144	; 0x90
 8000de4:	50ab      	str	r3, [r5, r2]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000de6:	002a      	movs	r2, r5
 8000de8:	6118      	str	r0, [r3, #16]
 8000dea:	23b8      	movs	r3, #184	; 0xb8
 8000dec:	32b8      	adds	r2, #184	; 0xb8
 8000dee:	50ea      	str	r2, [r5, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000df0:	002b      	movs	r3, r5
 8000df2:	22bc      	movs	r2, #188	; 0xbc
 8000df4:	33bc      	adds	r3, #188	; 0xbc
 8000df6:	50ab      	str	r3, [r5, r2]
  tqp->prev = (thread_t *)tqp;
 8000df8:	3204      	adds	r2, #4
 8000dfa:	50ab      	str	r3, [r5, r2]
 8000dfc:	6160      	str	r0, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 8000dfe:	f7ff fa97 	bl	8000330 <chSchWakeupS.constprop.7>
  chSysUnlock();
 8000e02:	f7ff fc55 	bl	80006b0 <chSysUnlock.lto_priv.8>
             (size >= THD_WORKING_AREA_SIZE(0)) &&
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8000e06:	4d4d      	ldr	r5, [pc, #308]	; (8000f3c <main+0x36c>)
 8000e08:	0028      	movs	r0, r5
 8000e0a:	f7ff fcc1 	bl	8000790 <chRegFindThreadByWorkingArea>
 8000e0e:	2800      	cmp	r0, #0
 8000e10:	d003      	beq.n	8000e1a <main+0x24a>
 8000e12:	b672      	cpsid	i
 8000e14:	4b4a      	ldr	r3, [pc, #296]	; (8000f40 <main+0x370>)
 8000e16:	62e3      	str	r3, [r4, #44]	; 0x2c
 8000e18:	e7fe      	b.n	8000e18 <main+0x248>
 8000e1a:	0029      	movs	r1, r5
 8000e1c:	002b      	movs	r3, r5
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000e1e:	2255      	movs	r2, #85	; 0x55
 8000e20:	3149      	adds	r1, #73	; 0x49
 8000e22:	31ff      	adds	r1, #255	; 0xff
 8000e24:	701a      	strb	r2, [r3, #0]
 8000e26:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000e28:	428b      	cmp	r3, r1
 8000e2a:	d1fb      	bne.n	8000e24 <main+0x254>
 8000e2c:	b672      	cpsid	i
 8000e2e:	f7ff fc57 	bl	80006e0 <_dbg_check_lock>
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000e32:	238e      	movs	r3, #142	; 0x8e
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e34:	002a      	movs	r2, r5
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000e36:	005b      	lsls	r3, r3, #1
 8000e38:	50ed      	str	r5, [r5, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e3a:	32dc      	adds	r2, #220	; 0xdc
 8000e3c:	3b10      	subs	r3, #16
 8000e3e:	50ea      	str	r2, [r5, r3]
 8000e40:	4a40      	ldr	r2, [pc, #256]	; (8000f44 <main+0x374>)
 8000e42:	3b20      	subs	r3, #32
 8000e44:	50ea      	str	r2, [r5, r3]
 8000e46:	2300      	movs	r3, #0
 8000e48:	22f0      	movs	r2, #240	; 0xf0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000e4a:	2184      	movs	r1, #132	; 0x84
  tp->state     = CH_STATE_WTSTART;
 8000e4c:	2002      	movs	r0, #2
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e4e:	50ab      	str	r3, [r5, r2]
 8000e50:	320c      	adds	r2, #12
 8000e52:	50ae      	str	r6, [r5, r2]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000e54:	0049      	lsls	r1, r1, #1
 8000e56:	3a7c      	subs	r2, #124	; 0x7c
 8000e58:	506a      	str	r2, [r5, r1]
  tp->state     = CH_STATE_WTSTART;
 8000e5a:	3118      	adds	r1, #24
 8000e5c:	5468      	strb	r0, [r5, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000e5e:	2122      	movs	r1, #34	; 0x22
 8000e60:	31ff      	adds	r1, #255	; 0xff
 8000e62:	546b      	strb	r3, [r5, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000e64:	311b      	adds	r1, #27
 8000e66:	506a      	str	r2, [r5, r1]
  tp->mtxlist   = NULL;
 8000e68:	32b8      	adds	r2, #184	; 0xb8
 8000e6a:	50ab      	str	r3, [r5, r2]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000e6c:	3a04      	subs	r2, #4
 8000e6e:	50ab      	str	r3, [r5, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000e70:	3a34      	subs	r2, #52	; 0x34
 8000e72:	3323      	adds	r3, #35	; 0x23
 8000e74:	3aff      	subs	r2, #255	; 0xff
 8000e76:	33ff      	adds	r3, #255	; 0xff
 8000e78:	54ea      	strb	r2, [r5, r3]
  tp->name      = name;
 8000e7a:	4a33      	ldr	r2, [pc, #204]	; (8000f48 <main+0x378>)
 8000e7c:	3b0a      	subs	r3, #10
 8000e7e:	50ea      	str	r2, [r5, r3]
  REG_INSERT(tp);
 8000e80:	228a      	movs	r2, #138	; 0x8a
 8000e82:	3b08      	subs	r3, #8
 8000e84:	50ec      	str	r4, [r5, r3]
 8000e86:	6963      	ldr	r3, [r4, #20]
 8000e88:	0052      	lsls	r2, r2, #1
 8000e8a:	1c68      	adds	r0, r5, #1
 8000e8c:	50ab      	str	r3, [r5, r2]
 8000e8e:	30ff      	adds	r0, #255	; 0xff
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000e90:	002a      	movs	r2, r5
 8000e92:	6118      	str	r0, [r3, #16]
 8000e94:	2394      	movs	r3, #148	; 0x94
 8000e96:	3229      	adds	r2, #41	; 0x29
 8000e98:	32ff      	adds	r2, #255	; 0xff
 8000e9a:	005b      	lsls	r3, r3, #1
 8000e9c:	50ea      	str	r2, [r5, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000e9e:	002b      	movs	r3, r5
 8000ea0:	2296      	movs	r2, #150	; 0x96
 8000ea2:	332d      	adds	r3, #45	; 0x2d
 8000ea4:	33ff      	adds	r3, #255	; 0xff
 8000ea6:	0052      	lsls	r2, r2, #1
 8000ea8:	50ab      	str	r3, [r5, r2]
  tqp->prev = (thread_t *)tqp;
 8000eaa:	3204      	adds	r2, #4
 8000eac:	50ab      	str	r3, [r5, r2]
 8000eae:	6160      	str	r0, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000eb0:	f7ff fa3e 	bl	8000330 <chSchWakeupS.constprop.7>
  chSysUnlock();
 8000eb4:	f7ff fbfc 	bl	80006b0 <chSysUnlock.lto_priv.8>
 8000eb8:	e7fe      	b.n	8000eb8 <main+0x2e8>
 8000eba:	46c0      	nop			; (mov r8, r8)
 8000ebc:	40021000 	.word	0x40021000
 8000ec0:	ffbfffff 	.word	0xffbfffff
 8000ec4:	40007000 	.word	0x40007000
 8000ec8:	65550000 	.word	0x65550000
 8000ecc:	0000ff30 	.word	0x0000ff30
 8000ed0:	11002222 	.word	0x11002222
 8000ed4:	2a80a0aa 	.word	0x2a80a0aa
 8000ed8:	48000400 	.word	0x48000400
 8000edc:	55545555 	.word	0x55545555
 8000ee0:	0000ffff 	.word	0x0000ffff
 8000ee4:	48000800 	.word	0x48000800
 8000ee8:	55555555 	.word	0x55555555
 8000eec:	48001400 	.word	0x48001400
 8000ef0:	40015800 	.word	0x40015800
 8000ef4:	000012bf 	.word	0x000012bf
 8000ef8:	e000e100 	.word	0xe000e100
 8000efc:	20000420 	.word	0x20000420
 8000f00:	200006c8 	.word	0x200006c8
 8000f04:	200006d0 	.word	0x200006d0
 8000f08:	20001800 	.word	0x20001800
 8000f0c:	20000578 	.word	0x20000578
 8000f10:	20000400 	.word	0x20000400
 8000f14:	08000711 	.word	0x08000711
 8000f18:	080011a0 	.word	0x080011a0
 8000f1c:	20000200 	.word	0x20000200
 8000f20:	e000ed00 	.word	0xe000ed00
 8000f24:	ff00ffff 	.word	0xff00ffff
 8000f28:	200004a0 	.word	0x200004a0
 8000f2c:	0800104c 	.word	0x0800104c
 8000f30:	08000311 	.word	0x08000311
 8000f34:	080001b1 	.word	0x080001b1
 8000f38:	08001184 	.word	0x08001184
 8000f3c:	20000580 	.word	0x20000580
 8000f40:	08001208 	.word	0x08001208
 8000f44:	080001e1 	.word	0x080001e1
 8000f48:	0800118c 	.word	0x0800118c
 8000f4c:	00000000 	.word	0x00000000

08000f50 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8000f50:	b570      	push	{r4, r5, r6, lr}
 8000f52:	0006      	movs	r6, r0
 8000f54:	b672      	cpsid	i
 8000f56:	f7ff fbc3 	bl	80006e0 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8000f5a:	4d11      	ldr	r5, [pc, #68]	; (8000fa0 <chThdExit+0x50>)
 8000f5c:	69ac      	ldr	r4, [r5, #24]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8000f5e:	6266      	str	r6, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8000f60:	0026      	movs	r6, r4
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8000f62:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8000f64:	3628      	adds	r6, #40	; 0x28
 8000f66:	4286      	cmp	r6, r0
 8000f68:	d006      	beq.n	8000f78 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8000f6a:	6803      	ldr	r3, [r0, #0]
 8000f6c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8000f6e:	f7ff f96f 	bl	8000250 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8000f72:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8000f74:	42b0      	cmp	r0, r6
 8000f76:	d1f8      	bne.n	8000f6a <chThdExit+0x1a>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8000f78:	2322      	movs	r3, #34	; 0x22
 8000f7a:	5ce3      	ldrb	r3, [r4, r3]
 8000f7c:	2b00      	cmp	r3, #0
 8000f7e:	d108      	bne.n	8000f92 <chThdExit+0x42>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8000f80:	2321      	movs	r3, #33	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8000f82:	5ce3      	ldrb	r3, [r4, r3]
 8000f84:	079b      	lsls	r3, r3, #30
 8000f86:	d104      	bne.n	8000f92 <chThdExit+0x42>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8000f88:	6922      	ldr	r2, [r4, #16]
 8000f8a:	6963      	ldr	r3, [r4, #20]
 8000f8c:	611a      	str	r2, [r3, #16]
 8000f8e:	6922      	ldr	r2, [r4, #16]
 8000f90:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8000f92:	200f      	movs	r0, #15
 8000f94:	f7ff fa04 	bl	80003a0 <chSchGoSleepS>
 8000f98:	b672      	cpsid	i
 8000f9a:	4b02      	ldr	r3, [pc, #8]	; (8000fa4 <chThdExit+0x54>)
 8000f9c:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000f9e:	e7fe      	b.n	8000f9e <chThdExit+0x4e>
 8000fa0:	20000420 	.word	0x20000420
 8000fa4:	08001034 	.word	0x08001034
	...

08000fb0 <__init_ram_areas>:
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000fb0:	2280      	movs	r2, #128	; 0x80
 8000fb2:	4694      	mov	ip, r2
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000fb4:	b5f0      	push	{r4, r5, r6, r7, lr}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8000fb6:	2600      	movs	r6, #0
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000fb8:	4f10      	ldr	r7, [pc, #64]	; (8000ffc <__init_ram_areas+0x4c>)
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000fba:	4d11      	ldr	r5, [pc, #68]	; (8001000 <__init_ram_areas+0x50>)
 8000fbc:	4c11      	ldr	r4, [pc, #68]	; (8001004 <__init_ram_areas+0x54>)
 8000fbe:	4b12      	ldr	r3, [pc, #72]	; (8001008 <__init_ram_areas+0x58>)
 8000fc0:	4912      	ldr	r1, [pc, #72]	; (800100c <__init_ram_areas+0x5c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000fc2:	44bc      	add	ip, r7
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000fc4:	429c      	cmp	r4, r3
 8000fc6:	d90d      	bls.n	8000fe4 <__init_ram_areas+0x34>
 8000fc8:	001a      	movs	r2, r3
      *p = *tp;
 8000fca:	c901      	ldmia	r1!, {r0}
 8000fcc:	c201      	stmia	r2!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000fce:	4294      	cmp	r4, r2
 8000fd0:	d8fb      	bhi.n	8000fca <__init_ram_areas+0x1a>
 8000fd2:	43da      	mvns	r2, r3
 8000fd4:	1914      	adds	r4, r2, r4
 8000fd6:	08a4      	lsrs	r4, r4, #2
 8000fd8:	3401      	adds	r4, #1
 8000fda:	00a4      	lsls	r4, r4, #2
 8000fdc:	191b      	adds	r3, r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000fde:	429d      	cmp	r5, r3
 8000fe0:	d902      	bls.n	8000fe8 <__init_ram_areas+0x38>
      *p = 0;
 8000fe2:	c340      	stmia	r3!, {r6}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000fe4:	429d      	cmp	r5, r3
 8000fe6:	d8fc      	bhi.n	8000fe2 <__init_ram_areas+0x32>
      *p = 0;
      p++;
    }
    rap++;
 8000fe8:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000fea:	4567      	cmp	r7, ip
 8000fec:	d004      	beq.n	8000ff8 <__init_ram_areas+0x48>
 8000fee:	68bc      	ldr	r4, [r7, #8]
 8000ff0:	68fd      	ldr	r5, [r7, #12]
 8000ff2:	6839      	ldr	r1, [r7, #0]
 8000ff4:	687b      	ldr	r3, [r7, #4]
 8000ff6:	e7e5      	b.n	8000fc4 <__init_ram_areas+0x14>
#endif
}
 8000ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000ffa:	46c0      	nop			; (mov r8, r8)
 8000ffc:	080010ac 	.word	0x080010ac
 8001000:	200006cc 	.word	0x200006cc
 8001004:	200006cc 	.word	0x200006cc
 8001008:	200006cc 	.word	0x200006cc
 800100c:	08001248 	.word	0x08001248

08001010 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001010:	e7fe      	b.n	8001010 <__default_exit>
 8001012:	46c0      	nop			; (mov r8, r8)
	...

08001020 <__late_init>:
 8001020:	4770      	bx	lr
 8001022:	46c0      	nop			; (mov r8, r8)
	...

08001030 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001030:	4770      	bx	lr
 8001032:	46c0      	nop			; (mov r8, r8)
